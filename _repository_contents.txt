
================================================================================
File: ./run_streamlit_apps.py
================================================================================

import subprocess
import os

# Activate the Conda environment and run the Streamlit apps
def main():
    # Path to your Conda environment's activation script
    conda_activate = "/config/miniconda3/etc/profile.d/conda.sh"
    conda_env_name = "iroils"
    
    # Activate Conda environment
    subprocess.run(f"source {conda_activate} && conda activate {conda_env_name}", shell=True, executable='/bin/bash')
    
    # Define the Streamlit apps and their ports
    apps = [
        ("/config/github/iROILS-Evaluations/app.py", 8501),
        ("/config/github/iROILS-Evaluations/user_submission.py", 8502),
        ("/config/github/iROILS-Evaluations/postgres_dashboard.py", 8503)
    ]
    
    processes = []
    
    # Run each app in its own subprocess
    for app_path, port in apps:
        process = subprocess.Popen(
            ["streamlit", "run", app_path, f"--server.port={port}"], 
            shell=False
        )
        processes.append(process)
    
    # Wait for all processes to finish
    for process in processes:
        process.wait()

if __name__ == "__main__":
    main()

================================================================================
File: ./config.ini
================================================================================

[API]
endpoint_home = http://192.168.1.5:11434/api/generate
endpoint_work = http://172.30.98.11:11434/api/generate

[Redis]
host_home = 192.168.1.4
host_work = 172.30.98.46
redis_port = 6379

[postgresql]
psql_home = 192.168.1.166
psql_work = 172.30.98.x  # Replace 'x' with the correct value for work
psql_port = 5432
psql_user = aalexandrian
psql_password = 1232
psql_dbname = iroils

[Summary_Model]
name = mistral
num_predict = 500
top_k = 15
top_p = 0.2
temperature = 0.01
num_ctx = 16000
prompt = "Task Objective: Produce a succinct and accurate summary of the event detailed below, reflecting only the information presented. Start the summary on a new line, immediately without spaces, and avoid unnecessary blank lines. Narrative: '{narrative}' Begin Summary:"

[Eval_Model]
name = mixtral
num_predict = 500
top_k = 10
top_p = 0.15
temperature = 0.01
num_ctx = 32000
prompt = "Based on the narrative and summary provided, please generate an evaluation. Start your evaluation with the word 'Grade:' followed by one of the following grades: 'Identical', 'Similar', 'Dissimilar', 'Irrelevant'. After the grade, provide a brief explanation of your grading decision. Here is the narrative: '{narrative}'. Here is the summary: '{summary}'. For example, a correct evaluation might be: 'Grade: Identical. The summary perfectly captures all the points in the narrative, using different words but conveying the same meaning. Do not deviate from this format'"

[Expert_Model]
name = mixtral
num_predict = 500
top_k = 15
top_p = 0.25
temperature = 0.01
num_ctx = 32000
prompt = "As a medical physicist, analyze the following patient case from an incident learning system. User Submitted Entry: '[mistral Summary]'. Cleaned Summary: '[Cleaned Summary]'. Processed Text: '[Processed Text]'. Identify any clinical issues, errors, or noteworthy patterns and list them as numbered points. For each identified issue, provide a list of suggested tags. The tags should be relevant, specific, consistent, brief, and comprehensive. The tags should be keywords or concepts relevant to the text and the field of radiation oncology, and limited to no more than 7 words. Please provide the tags in the following format: 'Suggested Tags: tag1, tag2, tag3, etc.'"

[Succinctor_Model]
name = mistral:latest
num_predict = 200
min_predict = 50
predict_scaling_factor = 120
top_k = 8
top_p = 0.1
temperature = 0.01
temperature_scaling_factor = 0.005
num_ctx = 8000
prompt = "Task Objective: {compression_instruction} Focus only on the most essential points and generate a summary that is no more than a few sentences. The summary should be as concise as possible while preserving the key details. Cleaned Narrative: '{cleaned_narrative}' Begin Summary:"

================================================================================
File: ./analysis_page.py
================================================================================

import streamlit as st

class AnalysisPage:
    def __init__(self, db_manager):
        self.db_manager = db_manager

    def show(self):
        st.header("Analysis Mode")

        # Institution Averages (existing code remains unchanged)
        st.subheader("Institution Averages")

        institutions = ["UAB", "MBPCC"]
        total_entries = 0
        total_evaluations = 0
        cumulative_summary_total = 0
        cumulative_tag_total = 0
        institution_stats_list = []

        # Calculate stats for each institution
        for institution in institutions:
            # Fetch entries and stats
            entries = self.db_manager.get_selected_entries(institution)
            total_entries += len(entries)

            stats = self.db_manager.get_institution_stats(institution)
            cumulative_summary = stats['cumulative_summary']
            cumulative_tag = stats['cumulative_tag']
            total_evals = stats['total_evaluations']

            # Compute averages
            avg_summary = cumulative_summary / total_evals if total_evals > 0 else 0.0
            avg_tag = cumulative_tag / total_evals if total_evals > 0 else 0.0

            total_evaluations += total_evals
            cumulative_summary_total += cumulative_summary
            cumulative_tag_total += cumulative_tag

            institution_stats_list.append({
                'Institution': institution,
                'Average Summary Score': round(avg_summary, 2),
                'Average Tag Score': round(avg_tag, 2),
                'Total Evaluations': total_evals
            })

        # Display stats for each institution
        for stats in institution_stats_list:
            st.write(f"**{stats['Institution']}**")
            st.write(f"- Average Summary Score: {stats['Average Summary Score']}")
            st.write(f"- Average Tag Score: {stats['Average Tag Score']}")
            st.write(f"- Total Evaluations: {stats['Total Evaluations']}")

        # Display combined averages across all institutions
        st.subheader("Combined Averages Across All Institutions")

        combined_avg_summary_score = cumulative_summary_total / total_evaluations if total_evaluations > 0 else 0.0
        combined_avg_tag_score = cumulative_tag_total / total_evaluations if total_evaluations > 0 else 0.0
        combined_aggregate_score = (combined_avg_summary_score + combined_avg_tag_score) / 2

        st.metric("Combined Average Summary Score", f"{combined_avg_summary_score:.2f}")
        st.metric("Combined Average Tag Score", f"{combined_avg_tag_score:.2f}")
        st.metric("Combined Aggregate Score", f"{combined_aggregate_score:.2f}")

        st.write(f"Total Evaluations Across All Institutions: {total_evaluations}")
        st.write(f"Total Entries in Database: {total_entries}")

        # Add Search/Jump to Specific Entry
        st.subheader("Search for Specific Entry by Event Number")
        event_number_search = st.text_input("Enter Event Number to Search")

        if st.button("Search Entry"):
            entry_found = None
            for institution in institutions:
                entries = self.db_manager.get_selected_entries(institution)
                entry_found = next((entry for entry in entries if entry.get('Event Number') == event_number_search), None)
                if entry_found:
                    break

            if entry_found:
                st.write(f"Entry Found: Event Number {entry_found.get('Event Number')}")
                evaluations = entry_found.get('Evaluations', [])
                if evaluations:
                    st.write("### Evaluations for this Entry")
                    for evaluation in evaluations:
                        st.write(f"Evaluator: {evaluation['Evaluator']}")
                        st.write(f"Summary Score: {evaluation['Summary Score']}")
                        st.write(f"Tag Score: {evaluation['Tag Score']}")
                        st.write(f"Feedback: {evaluation['Feedback']}")
                        st.markdown("---")
                else:
                    st.write("No evaluations found for this entry.")
            else:
                st.write("Entry not found.")

        # Filter Evaluations by Evaluator
        st.subheader("Filter Evaluations by Evaluator")
        # Fetch evaluators from the database
        evaluators = self.db_manager.get_all_evaluators()
        selected_evaluator = st.selectbox("Select Evaluator", evaluators)


        if selected_evaluator:
            st.write(f"Evaluations by {selected_evaluator}")
            for institution in institutions:
                entries = self.db_manager.get_selected_entries(institution)
                for entry in entries:
                    evaluations = entry.get('Evaluations', [])
                    for evaluation in evaluations:
                        if evaluation['Evaluator'] == selected_evaluator:
                            st.write(f"### Entry: {entry.get('Event Number')}")
                            st.write(f"Summary Score: {evaluation['Summary Score']}")
                            st.write(f"Tag Score: {evaluation['Tag Score']}")
                            st.write(f"Feedback: {evaluation['Feedback']}")
                            st.markdown("---")

================================================================================
File: ./_pyshare.py
================================================================================

import os

def collect_files(root_dir, extensions):
    """Recursively collect files with the given extensions."""
    collected_files = []
    for dirpath, _, filenames in os.walk(root_dir):
        for filename in filenames:
            if filename.lower().endswith(extensions):
                filepath = os.path.join(dirpath, filename)
                collected_files.append(filepath)
    return collected_files

def write_to_output(collected_files, output_file):
    """Write the contents of the collected files to the output file with delimiters."""
    with open(output_file, 'w', encoding='utf-8') as outfile:
        for filepath in collected_files:
            outfile.write(f"\n{'='*80}\n")
            outfile.write(f"File: {filepath}\n")
            outfile.write(f"{'='*80}\n\n")
            try:
                with open(filepath, 'r', encoding='utf-8') as infile:
                    contents = infile.read()
                    outfile.write(contents)
            except Exception as e:
                outfile.write(f"Error reading file: {e}\n")

def main():
    # Specify the root directory of your repository
    root_dir = '.'  # Change this to the path of your repository if needed

    # Specify the output file
    output_file = '_repository_contents.txt'

    # Define the file extensions to include
    extensions = ('.py', '.ipynb', '.ini', '.txt')

    # Collect the files
    collected_files = collect_files(root_dir, extensions)

    # Write to the output file
    write_to_output(collected_files, output_file)

    print(f"Collected {len(collected_files)} files. Contents written to '{output_file}'.")

if __name__ == "__main__":
    main()

================================================================================
File: ./network_resolver.py
================================================================================

# network_resolver.py

import socket
import logging

class NetworkResolver:
    def __init__(self, config):
        self.config = config
        self.logger = logging.getLogger(__name__)

    def get_local_ip(self):
        """Get the local IP address of the machine."""
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        try:
            # Use an external server to determine local IP
            s.connect(('8.8.8.8', 1))
            local_ip = s.getsockname()[0]
            self.logger.info(f"Local IP detected: {local_ip}")
            return local_ip
        except Exception as e:
            self.logger.error(f"Failed to determine local IP: {e}")
            raise Exception("Unable to determine local IP address.")
        finally:
            s.close()

    def resolve_environment(self, local_ip):
        """Determine the environment based on the local IP address."""
        if local_ip.startswith('192.168.1.'):
            self.logger.info("Detected home network.")
            return 'home'
        elif local_ip.startswith('172.30.98.'):
            self.logger.info("Detected work network.")
            return 'work'
        else:
            self.logger.warning(f"Unknown subnet {local_ip}. Defaulting to 'home' environment.")
            return 'home'  # Default to 'home' if subnet is unknown
================================================================================
File: ./_repository_contents.txt
================================================================================


================================================================================
File: ./postgres_dashboard.py
================================================================================

import streamlit as st
import pandas as pd
import psycopg2
import configparser

# Load configuration
config = configparser.ConfigParser()
config.read('config.ini')

# PostgreSQL connection settings
psql_host = config['postgresql']['psql_home']
psql_port = config['postgresql'].getint('psql_port', 5432)
psql_user = config['postgresql']['psql_user']
psql_password = config['postgresql']['psql_password']
psql_dbname = config['postgresql']['psql_dbname']

# Establish PostgreSQL connection
@st.cache_data
def load_data(query, params=None):
    try:
        conn = psycopg2.connect(
            host=psql_host,
            port=psql_port,
            user=psql_user,
            password=psql_password,
            dbname=psql_dbname
        )
        df = pd.read_sql_query(query, conn, params=params)
        conn.close()
        return df
    except Exception as e:
        st.error(f"Error loading data from PostgreSQL: {e}")
        return pd.DataFrame()

# Main Dashboard - Show Running Averages
st.title("PostgreSQL Evaluation Dashboard")

st.header("Overall Statistics")
query_averages = """
SELECT 
    COALESCE(AVG(summary_score), 0) as avg_summary, 
    COALESCE(AVG(tag_score), 0) as avg_tag, 
    COUNT(*) as total_evaluations
FROM evaluations;
"""
average_data = load_data(query_averages)

if not average_data.empty:
    avg_summary = average_data['avg_summary'][0]
    avg_tag = average_data['avg_tag'][0]
    total_evaluations = average_data['total_evaluations'][0]

    # Check if total_evaluations is zero to handle division by zero
    if total_evaluations == 0:
        avg_summary_display = "N/A"
        avg_tag_display = "N/A"
    else:
        avg_summary_display = f"{avg_summary:.2f}"
        avg_tag_display = f"{avg_tag:.2f}"

    st.metric("Average Summary Score", avg_summary_display)
    st.metric("Average Tag Score", avg_tag_display)
    st.metric("Total Evaluations", total_evaluations)
else:
    st.write("No data available to display statistics.")


# Evaluator Selection and List of Entries
st.header("Evaluator Data")
evaluator_query = """
SELECT DISTINCT evaluator FROM evaluations ORDER BY evaluator;
"""
evaluators = load_data(evaluator_query)['evaluator'].tolist()

selected_evaluator = st.selectbox("Select Evaluator", evaluators)

if selected_evaluator:
    # List of entries evaluated by the selected evaluator
    entry_query = """
    SELECT 
        entry_number, summary_score, tag_score, feedback
    FROM evaluations
    WHERE evaluator = %s
    ORDER BY entry_number;
    """
    entries = load_data(entry_query, (selected_evaluator,))

    if not entries.empty:
        st.write(f"### Entries Evaluated by {selected_evaluator}")
        for idx, row in entries.iterrows():
            entry_number = row['entry_number']
            summary_score = row['summary_score']
            tag_score = row['tag_score']

            if st.button(f"View Entry {entry_number}", key=f"entry_{entry_number}"):
                st.session_state['selected_entry'] = entry_number
                st.session_state['selected_evaluator'] = selected_evaluator
                st.rerun()

            st.write(f"Entry #{entry_number}: Summary Score = {summary_score}, Tag Score = {tag_score}")

    else:
        st.write("This evaluator has not evaluated any entries.")

# Display Selected Entry Details
if 'selected_entry' in st.session_state and 'selected_evaluator' in st.session_state:
    selected_entry = st.session_state['selected_entry']
    selected_evaluator = st.session_state['selected_evaluator']

    st.header(f"Details for Entry #{selected_entry}")

    entry_detail_query = """
    SELECT 
        e.data->>'Narrative' AS narrative,
        e.data->>'Succinct Summary' AS succinct_summary,
        e.data->>'Assigned Tags' AS assigned_tags,
        ev.summary_score,
        ev.tag_score,
        ev.feedback
    FROM evaluations ev
    JOIN entries e ON ev.entry_number = e.event_number AND ev.institution = e.institution
    WHERE ev.evaluator = %s AND ev.entry_number = %s;
    """
    entry_details = load_data(entry_detail_query, params=(selected_evaluator, selected_entry))

    if not entry_details.empty:
        details = entry_details.iloc[0]
        st.markdown("#### Narrative")
        st.write(details['narrative'])

        st.markdown("#### Succinct Summary")
        st.write(details['succinct_summary'])

        st.markdown("#### Assigned Tags")
        st.write(details['assigned_tags'])

        st.markdown("#### Evaluation Scores")
        st.write(f"**Summary Score:** {details['summary_score']}")
        st.write(f"**Tag Score:** {details['tag_score']}")

        st.markdown("#### Feedback")
        st.write(details['feedback'])
    else:
        st.write(f"No details found for Entry #{selected_entry}.")
================================================================================
File: ./overview_page.py
================================================================================

import streamlit as st

class OverviewPage:
    def __init__(self, db_manager, institution):
        self.db_manager = db_manager
        self.institution = institution

    def show(self):
        st.header(f"Overview Mode - {self.institution}")

        # Use entries from session state
        entries = st.session_state.get('all_entries', [])
        total_entries = len(entries)

        if total_entries == 0:
            st.warning("No entries available.")
            return

        # Add search input and filter options
        self.render_search_and_filters(entries)

        # Get filtered entries
        filtered_entries = self.get_filtered_entries(entries)
        total_filtered_entries = len(filtered_entries)

        if total_filtered_entries == 0:
            st.warning("No entries match the search and filter criteria.")
            return

        # Allow the user to jump to a selected entry
        self.render_entry_navigation(filtered_entries, total_filtered_entries)

    def render_search_and_filters(self, entries):
        """Render search and filter options for overview."""
        st.markdown("### Search and Filter Selected Entries")

        # Search input
        st.text_input("Search by Narrative or Assigned Tags", key='overview_search_query')

        # Filter by Assigned Tags
        all_tags = {tag.strip() for entry in entries for tag in entry.get('Assigned Tags', '').split(',') if tag.strip()}
        st.multiselect("Filter by Assigned Tags", options=sorted(all_tags), key='overview_tag_filter')

    def get_filtered_entries(self, entries):
        """Filter entries based on search, tag criteria, and selection status."""
        search_query = st.session_state.get('overview_search_query', '').lower()
        tag_filter = st.session_state.get('overview_tag_filter', [])

        # Filter entries that are selected for evaluation
        filtered_entries = [
            entry for entry in entries
            if entry.get('Selected', 'Do Not Select') == 'Select for Evaluation'
        ]

        # Apply search filter
        if search_query:
            filtered_entries = [
                entry for entry in filtered_entries
                if search_query in entry.get('Narrative', '').lower() or
                search_query in entry.get('Assigned Tags', '').lower()
            ]

        # Apply tag filter
        if tag_filter:
            filtered_entries = [
                entry for entry in filtered_entries
                if any(tag.strip() in tag_filter for tag in entry.get('Assigned Tags', '').split(','))
            ]

        return filtered_entries


    def render_entry_navigation(self, filtered_entries, total_filtered_entries):
        """Render a dropdown to allow users to jump to a specific entry."""
        st.markdown("### Jump to Selected Entry")
        selected_event = st.selectbox("Select Event", [entry.get('Event Number', 'N/A') for entry in filtered_entries], key='overview_event_select')

        selected_entry = next((entry for entry in filtered_entries if entry.get('Event Number') == selected_event), None)
        
        if selected_entry:
            self.display_entry_details(selected_entry, total_filtered_entries)

    def display_entry_details(self, current_entry, total_filtered_entries):
        """Display the details of the current entry."""
        st.write(f"### Event Number: {current_entry.get('Event Number', 'N/A')}")
        st.write(f"**Narrative:** {current_entry.get('Narrative', '')}")
        st.write(f"**Assigned Tags:** {current_entry.get('Assigned Tags', '')}")
        st.write(f"**Succinct Summary:** {current_entry.get('Succinct Summary', '')}")

        # Summary
        st.markdown(f"**Total Selected Entries:** {total_filtered_entries}")
        st.markdown(f"**Total Entries in Database:** {len(st.session_state['all_entries'])}")

================================================================================
File: ./login_manager.py
================================================================================

# login_manager.py

import time

class LoginManager:
    def __init__(self):
        # Admin credentials
        self.admin_credentials = {
            'admin_username': '',
            'admin_password': ''
        }

        # Evaluator credentials mapped to their respective institutions
        self.evaluator_credentials = {
            'astam': {'password': '123', 'institution': 'MBPCC'},
            'kkirby': {'password': 'resin', 'institution': 'UAB'},
            'dsolis': {'password': 'T2hP6vC4', 'institution': 'MBPCC'},
            'gpitcher': {'password': 'B3kN9wL5', 'institution': 'MBPCC'},
            'jashford': {'password': 'P6vT8mJ2', 'institution': 'MBPCC'},
            'hspears': {'password': 'R4xB2gW9', 'institution': 'MBPCC'},
            'aalexandrian': {'password': '1232', 'institution': 'UAB'},
            'nviscariello': {'password': 'Y8pK4vH1', 'institution': 'UAB'},
            'rsullivan': {'password': 'C7bM5nW2', 'institution': 'UAB'},
            'jbelliveau': {'password': 'F3rP6yV8', 'institution': 'UAB'},
            'lrobinson': {'password': 'G5tV2cQ9', 'institution': 'UAB'},
        }

        # Session timeout threshold in seconds (e.g., 15 minutes)
        self.session_timeout = 15 * 60

    def login(self, session_state, username, password):
        if username == self.admin_credentials['admin_username'] and password == self.admin_credentials['admin_password']:
            session_state['user_role'] = 'admin'
            session_state['last_activity'] = time.time()
            return True
        else:
            return False

    def evaluator_login(self, session_state, username, password):
        evaluator_data = self.evaluator_credentials.get(username)
        if evaluator_data and evaluator_data['password'] == password:
            session_state['evaluator_logged_in'] = True
            session_state['evaluator_username'] = username
            session_state['user_role'] = 'evaluator'
            session_state['evaluator_institution'] = evaluator_data['institution']  # Assign institution
            session_state['last_activity'] = time.time()
            return True
        return False

    def logout(self, session_state):
        session_state.pop('user_role', None)
        session_state.pop('evaluator_logged_in', None)
        session_state.pop('evaluator_username', None)
        session_state.pop('evaluator_institution', None)
        session_state.pop('last_activity', None)

    def check_session_timeout(self, session_state):
        """Check if the user session has timed out."""
        if 'last_activity' in session_state:
            current_time = time.time()
            if current_time - session_state['last_activity'] > self.session_timeout:
                self.logout(session_state)
                return True
            else:
                session_state['last_activity'] = current_time  # Update last activity timestamp
        return False

================================================================================
File: ./app.py
================================================================================

import streamlit as st
import configparser
import logging
import pandas as pd
from database_manager import DatabaseManager
from network_resolver import NetworkResolver
from login_manager import LoginManager
from selection_page import SelectionPage
from overview_page import OverviewPage
from analysis_page import AnalysisPage
from analysis_methods import evaluate_and_tag_entries  # Import evaluation methods

# Set up logging for debugging
logging.basicConfig(level=logging.WARNING)

# Load the configuration file
config = configparser.ConfigParser()
config.read('config.ini')

# Initialize the NetworkResolver
resolver = NetworkResolver(config)

# Determine the environment using the NetworkResolver
local_ip = resolver.get_local_ip()
environment = resolver.resolve_environment(local_ip)

# Extract PostgreSQL credentials based on the environment
psql_host = config['postgresql'][f'psql_{environment}']  # Use 'psql_home' or 'psql_work'
psql_port = config['postgresql'].getint('psql_port', 5432)
psql_user = config['postgresql']['psql_user']
psql_password = config['postgresql']['psql_password']
psql_dbname = config['postgresql']['psql_dbname']

# Initialize the DatabaseManager with the resolved credentials
db_manager = DatabaseManager(
    psql_host=psql_host,
    psql_port=psql_port,
    psql_user=psql_user,
    psql_password=psql_password,
    psql_dbname=psql_dbname
)

# Initialize the LoginManager
login_manager = LoginManager()

# Streamlit UI
st.title("Admin Dashboard")

# Check if user is logged in by verifying session state
if 'logged_in' not in st.session_state:
    st.session_state['logged_in'] = False

def reset_session_state():
    """Reset session state variables."""
    st.session_state.pop('all_entries', None)
    st.session_state.pop('total_entries', None)
    st.session_state.pop('current_index', None)

def reset_institution_data():
    selected_institution = st.session_state.get('institution_select', 'UAB')  # Default to 'UAB' if not set
    try:
        st.write(f"Resetting data for institution: {selected_institution}")
        db_manager.reset_data(selected_institution)  # Reset data in PostgreSQL

        # Ensure session state is cleared after resetting
        reset_session_state()
        st.success(f"All data for {selected_institution} has been reset.")

    except Exception as e:
        st.error(f"Error during reset: {e}")

# If the user is not logged in, show the login form
if not st.session_state['logged_in']:
    st.markdown("## Admin Login")
    admin_username = st.text_input("Username")
    admin_password = st.text_input("Password", type="password")

    if st.button("Login"):
        if login_manager.login(st.session_state, admin_username, admin_password):
            st.session_state['logged_in'] = True
            st.success("Login successful!")
            st.rerun()
        else:
            st.error("Invalid username or password")
else:
    # Check if the user has admin role
    if st.session_state.get('user_role') != 'admin':
        st.error("You do not have permission to access this page.")
        if st.button("Logout"):
            login_manager.logout(st.session_state)
            st.session_state['logged_in'] = False
            st.rerun()
    else:
        # If the user is logged in and has admin role, display the dashboard
        institution = st.selectbox("Select Institution", ["UAB", "MBPCC"], key='institution_select', on_change=reset_session_state)

        # Pull all entries from PostgreSQL or refresh when institution is changed
        if 'all_entries' not in st.session_state:
            all_entries = db_manager.get_selected_entries(institution)

            if not all_entries:
                st.session_state['all_entries'] = []
                st.session_state['total_entries'] = 0
                st.warning("No data available for the selected institution.")
            else:
                st.session_state['all_entries'] = all_entries
                st.session_state['total_entries'] = len(all_entries)
        else:
            all_entries = st.session_state['all_entries']
            st.session_state['total_entries'] = len(all_entries)

        # Choose the mode and display pages
        mode = st.radio("Choose Mode", ["Selection Mode", "Overview Mode", "Analysis Mode"], index=0)

        if mode == "Analysis Mode" and st.session_state['total_entries'] > 0:
            # Perform analysis using analysis_methods.py
            analyzed_entries = evaluate_and_tag_entries(all_entries)
            # Process analysis and display the results
            analysis_page = AnalysisPage(db_manager)
            analysis_page.show()

        elif mode == "Selection Mode" and st.session_state['total_entries'] > 0:
            selection_page = SelectionPage(db_manager, institution)
            selection_page.show()
        elif mode == "Overview Mode":
            overview_page = OverviewPage(db_manager, institution)
            overview_page.show()

            # Admin options for data reset and uploads
            st.markdown("### Data Management")
            col1, col2 = st.columns([1, 1])

            with col1:
                if st.button("Reset Data"):
                    reset_institution_data()
                    st.rerun()

        # Handle data upload
        st.markdown("### Upload New Data")
        with st.form(key='upload_form'):
            uploaded_file = st.file_uploader("Upload New Data", type="xlsx")
            submit_upload = st.form_submit_button('Upload')

        if submit_upload:
            if uploaded_file is not None:
                try:
                    # Read the uploaded file into a pandas DataFrame
                    df = pd.read_excel(uploaded_file)

                    # Replace NaN values with None (null in JSON)
                    df = df.where(pd.notnull(df), None)

                    # Remove 'Selected' column if it exists
                    if 'Selected' in df.columns:
                        df.drop(columns=['Selected'], inplace=True)
                        st.write("Removed 'Selected' column from uploaded data.")

                    # Convert the DataFrame to a list of dictionaries (entries)
                    new_entries = df.to_dict(orient="records")

                    # Ensure that 'Selected' is set to 'Do Not Select' by default
                    for entry in new_entries:
                        entry['Selected'] = 'Do Not Select'  # Force 'Do Not Select' for every entry

                    logging.info(f"Parsed {len(new_entries)} entries from the uploaded file.")

                    # Save entries to the database (PostgreSQL)
                    db_manager.save_selected_entries(institution, new_entries)

                    # Force reload the entries into session state
                    all_entries = db_manager.get_selected_entries(institution)
                    st.session_state['all_entries'] = all_entries
                    st.session_state['total_entries'] = len(all_entries)

                    st.success(f"New data for {institution} uploaded successfully!")
                    st.rerun()  # Refresh the page so that the new data is displayed immediately
                except Exception as e:
                    logging.error(f"Error processing uploaded file: {e}")
                    st.error(f"Error processing uploaded file: {e}")
            else:
                st.warning("Please upload a file before clicking 'Upload'.")


            if st.button("Logout"):
                login_manager.logout(st.session_state)
                st.session_state['logged_in'] = False
                st.rerun()

================================================================================
File: ./database_manager.py
================================================================================

import psycopg2
import psycopg2.extras
import json
import logging

class DatabaseManager:
    def __init__(self, psql_host, psql_port, psql_user, psql_password, psql_dbname):
        self.logger = logging.getLogger(__name__)

        # Initialize PostgreSQL connection
        try:
            self.connection = psycopg2.connect(
                host=psql_host,
                port=psql_port,
                user=psql_user,
                password=psql_password,
                dbname=psql_dbname
            )
            self.connection.autocommit = True
            self.logger.info("Connected to PostgreSQL successfully.")
            self.initialize_postgresql_tables()
            self.ensure_unique_constraints()  # Ensure unique constraints are created
        except Exception as e:
            self.logger.error(f"Failed to connect to PostgreSQL: {e}")
            raise e

    def initialize_postgresql_tables(self):
        try:
            with self.connection.cursor() as cursor:
                # Create entries table
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS entries (
                        id SERIAL PRIMARY KEY,
                        institution VARCHAR(255),
                        event_number VARCHAR(255),
                        data JSONB
                    );
                """)
                # Create evaluations table
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS evaluations (
                        id SERIAL PRIMARY KEY,
                        institution VARCHAR(255),
                        evaluator VARCHAR(255),
                        entry_number VARCHAR(255),
                        summary_score INTEGER,
                        tag_score INTEGER,
                        feedback TEXT
                    );
                """)
                # Create institution_stats table
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS institution_stats (
                        institution VARCHAR(255) PRIMARY KEY,
                        cumulative_summary FLOAT,
                        cumulative_tag FLOAT,
                        total_evaluations INTEGER
                    );
                """)
            self.logger.info("PostgreSQL tables initialized successfully.")
        except Exception as e:
            self.logger.error(f"Error initializing PostgreSQL tables: {e}")
            raise e

    def ensure_unique_constraints(self):
        """Ensures that the unique constraints for entries and evaluations exist."""
        try:
            with self.connection.cursor() as cursor:
                # Ensure unique constraint on entries (institution, event_number)
                cursor.execute("""
                    SELECT conname 
                    FROM pg_constraint 
                    WHERE conname = 'unique_institution_event_number';
                """)
                result = cursor.fetchone()
                if not result:
                    cursor.execute("""
                        ALTER TABLE entries
                        ADD CONSTRAINT unique_institution_event_number UNIQUE (institution, event_number);
                    """)
                    self.logger.info("Unique constraint for institution and event_number created.")
                else:
                    self.logger.info("Unique constraint for institution and event_number already exists.")

                # Ensure unique constraint on evaluations (institution, evaluator, entry_number)
                cursor.execute("""
                    SELECT conname 
                    FROM pg_constraint 
                    WHERE conname = 'unique_evaluation';
                """)
                result = cursor.fetchone()
                if not result:
                    cursor.execute("""
                        ALTER TABLE evaluations
                        ADD CONSTRAINT unique_evaluation UNIQUE (institution, evaluator, entry_number);
                    """)
                    self.logger.info("Unique constraint for evaluations created.")
                else:
                    self.logger.info("Unique constraint for evaluations already exists.")
        except Exception as e:
            self.logger.error(f"Error ensuring unique constraints: {e}")
            raise e

    def reset_data(self, institution):
        try:
            institution_clean = institution.strip().lower()
            self.logger.info(f"Attempting to reset data for institution: {institution_clean}")

            with self.connection.cursor() as cursor:
                # Deleting entries for the institution
                cursor.execute("DELETE FROM entries WHERE LOWER(TRIM(institution)) = %s;", (institution_clean,))
                deleted_entries = cursor.rowcount
                self.logger.info(f"Deleted {deleted_entries} entries for {institution_clean} from PostgreSQL.")

                # Deleting evaluations for the institution
                cursor.execute("DELETE FROM evaluations WHERE LOWER(TRIM(institution)) = %s;", (institution_clean,))
                deleted_evaluations = cursor.rowcount
                self.logger.info(f"Deleted {deleted_evaluations} evaluations for {institution_clean} from PostgreSQL.")

                # Deleting stats for the institution
                cursor.execute("DELETE FROM institution_stats WHERE LOWER(TRIM(institution)) = %s;", (institution_clean,))
                deleted_stats = cursor.rowcount
                self.logger.info(f"Deleted {deleted_stats} institution stats for {institution_clean} from PostgreSQL.")

            self.logger.info(f"All data for {institution_clean} has been reset.")
        except Exception as e:
            self.logger.error(f"Error resetting data for {institution_clean}: {e}")
            raise e

    def get_selected_entries(self, institution):
        try:
            institution_clean = institution.strip().lower()
            with self.connection.cursor(cursor_factory=psycopg2.extras.RealDictCursor) as cursor:
                cursor.execute("""
                    SELECT data
                    FROM entries
                    WHERE LOWER(TRIM(institution)) = %s;
                """, (institution_clean,))
                results = cursor.fetchall()
                entries = [record['data'] for record in results]
                self.logger.debug(f"Fetched {len(entries)} selected entries for {institution_clean} from PostgreSQL.")
                return entries
        except Exception as e:
            self.logger.error(f"Error fetching selected entries for {institution}: {e}")
            return []

    def save_selected_entries(self, institution, entries):
        try:
            with self.connection.cursor() as cursor:
                for entry in entries:
                    event_number = entry.get('Event Number')
                    if event_number is None:
                        continue  # Skip entries without an Event Number

                    # Convert entry to JSON string
                    json_data = json.dumps(entry)

                    # Insert or update the entry
                    cursor.execute("""
                        INSERT INTO entries (institution, event_number, data)
                        VALUES (%s, %s, %s)
                        ON CONFLICT (institution, event_number) DO UPDATE
                        SET data = EXCLUDED.data;
                    """, (institution.lower(), event_number, json_data))

            self.connection.commit()
            self.logger.debug(f"Inserted/Updated {len(entries)} entries for institution {institution}.")
        except Exception as e:
            self.logger.error(f"Error saving selected entries: {e}")
            raise e  # Reraise exception to be handled by the calling function


    def update_entry(self, institution, updated_entry):
        try:
            institution_clean = institution.strip().lower()
            # Update entry in PostgreSQL
            with self.connection.cursor() as cursor:
                cursor.execute("""
                    UPDATE entries
                    SET data = %s
                    WHERE LOWER(TRIM(institution)) = %s AND event_number = %s;
                """, (json.dumps(updated_entry), institution_clean, updated_entry.get('Event Number')))
            self.logger.debug(f"Entry {updated_entry['Event Number']} updated in PostgreSQL.")
        except Exception as e:
            self.logger.error(f"Error updating entry {updated_entry['Event Number']} for {institution_clean}: {e}")
            raise e

    def update_entries_batch(self, institution, entries):
        """Batch update multiple entries in PostgreSQL."""
        try:
            institution_clean = institution.strip().lower()

            # Update entries in PostgreSQL
            with self.connection.cursor() as cursor:
                insert_query = """
                    INSERT INTO entries (institution, event_number, data)
                    VALUES %s
                    ON CONFLICT (institution, event_number)
                    DO UPDATE SET data = EXCLUDED.data;
                """
                values = [
                    (institution_clean, entry.get('Event Number', ''), json.dumps(entry))
                    for entry in entries
                ]
                psycopg2.extras.execute_values(
                    cursor, insert_query, values, template=None, page_size=100
                )
            self.logger.debug(f"Batch updated {len(entries)} entries for {institution_clean} in PostgreSQL.")
        except Exception as e:
            self.logger.error(f"Error batch updating entries for {institution_clean}: {e}")
            raise e

    def get_evaluation(self, evaluator, entry_number, institution):
        try:
            institution_clean = institution.strip().lower()
            with self.connection.cursor(cursor_factory=psycopg2.extras.RealDictCursor) as cursor:
                cursor.execute("""
                    SELECT *
                    FROM evaluations
                    WHERE evaluator = %s AND entry_number = %s AND LOWER(TRIM(institution)) = %s;
                """, (evaluator, entry_number, institution_clean))
                result = cursor.fetchone()
                if result:
                    self.logger.debug(f"Retrieved evaluation for evaluator {evaluator}, entry {entry_number}.")
                    return dict(result)
                else:
                    self.logger.debug(f"No evaluation found for evaluator {evaluator}, entry {entry_number}.")
                    return None
        except Exception as e:
            self.logger.error(f"Error fetching evaluation for evaluator {evaluator}, entry {entry_number}: {e}")
            return None

    def save_evaluation(self, evaluator, entry_number, institution, summary_score, tag_score, feedback):
        try:
            institution_clean = institution.strip().lower()
            with self.connection.cursor() as cursor:
                # Use UPSERT to insert or update the evaluation
                cursor.execute("""
                    INSERT INTO evaluations (institution, evaluator, entry_number, summary_score, tag_score, feedback)
                    VALUES (%s, %s, %s, %s, %s, %s)
                    ON CONFLICT (institution, evaluator, entry_number)
                    DO UPDATE SET summary_score = EXCLUDED.summary_score,
                                  tag_score = EXCLUDED.tag_score,
                                  feedback = EXCLUDED.feedback;
                """, (institution_clean, evaluator, entry_number, summary_score, tag_score, feedback))
            self.logger.debug(f"Saved evaluation for evaluator {evaluator}, entry {entry_number}.")
        except Exception as e:
            self.logger.error(f"Error saving evaluation for evaluator {evaluator}, entry {entry_number}: {e}")
            raise e

    def update_institution_stats(self, institution, summary_score, tag_score, is_new_evaluation, old_summary_score=0, old_tag_score=0):
        try:
            summary_score = float(summary_score)
            old_summary_score = float(old_summary_score)
            summary_diff = summary_score - old_summary_score
            tag_score = float(tag_score)
            old_tag_score = float(old_tag_score)
            tag_diff = tag_score - old_tag_score

            with self.connection.cursor() as cursor:
                if is_new_evaluation:
                    cursor.execute("""
                        INSERT INTO institution_stats (institution, cumulative_summary, cumulative_tag, total_evaluations)
                        VALUES (%s, %s, %s, 1)
                        ON CONFLICT (institution)
                        DO UPDATE SET 
                            cumulative_summary = institution_stats.cumulative_summary + EXCLUDED.cumulative_summary,
                            cumulative_tag = institution_stats.cumulative_tag + EXCLUDED.cumulative_tag,
                            total_evaluations = institution_stats.total_evaluations + 1;
                    """, (institution, summary_score, tag_score))
                else:
                    cursor.execute("""
                        UPDATE institution_stats
                        SET cumulative_summary = cumulative_summary + %s,
                            cumulative_tag = cumulative_tag + %s
                        WHERE institution = %s;
                    """, (summary_diff, tag_diff, institution))
            self.logger.info(f"Updated stats for {institution} after evaluation.")
        except Exception as e:
            self.logger.error(f"Error updating institution stats for {institution}: {e}")
            raise e


    def get_institution_stats(self, institution):
        try:
            institution_clean = institution.strip().lower()
            with self.connection.cursor() as cursor:
                cursor.execute("""
                    SELECT cumulative_summary, cumulative_tag, total_evaluations
                    FROM institution_stats
                    WHERE LOWER(TRIM(institution)) = %s;
                """, (institution_clean,))
                result = cursor.fetchone()
                if result:
                    cumulative_summary, cumulative_tag, total_evaluations = result
                    self.logger.debug(f"Fetched institution stats for {institution}.")
                    return {
                        'cumulative_summary': cumulative_summary,
                        'cumulative_tag': cumulative_tag,
                        'total_evaluations': total_evaluations
                    }
                else:
                    self.logger.debug(f"No institution stats found for {institution}.")
                    return {
                        'cumulative_summary': 0.0,
                        'cumulative_tag': 0.0,
                        'total_evaluations': 0
                    }
        except Exception as e:
            self.logger.error(f"Error fetching institution stats for {institution}: {e}")
            return {
                'cumulative_summary': 0.0,
                'cumulative_tag': 0.0,
                'total_evaluations': 0
            }

    def count_evaluations_by_evaluator(self, evaluator_username, institution):
        try:
            institution_clean = institution.strip().lower()
            with self.connection.cursor() as cursor:
                cursor.execute("""
                    SELECT COUNT(*)
                    FROM evaluations
                    WHERE evaluator = %s AND LOWER(TRIM(institution)) = %s;
                """, (evaluator_username, institution_clean))
                result = cursor.fetchone()
                count = result[0] if result else 0
                self.logger.debug(f"Evaluator {evaluator_username} has completed {count} evaluations.")
                return count
        except Exception as e:
            self.logger.error(f"Error counting evaluations for evaluator {evaluator_username}: {e}")
            return 0

    def check_selected_status(self, institution):
        try:
            institution_clean = institution.strip().lower()
            with self.connection.cursor() as cursor:
                cursor.execute("""
                    SELECT data->>'Selected' AS selected_status, COUNT(*)
                    FROM entries
                    WHERE LOWER(TRIM(institution)) = %s
                    GROUP BY selected_status;
                """, (institution_clean,))
                results = cursor.fetchall()
                for status, count in results:
                    self.logger.info(f"Selected status '{status}': {count} entries")
        except Exception as e:
            self.logger.error(f"Error checking selected status for {institution}: {e}")

    def get_all_entries(self, institution):
        return self.get_selected_entries(institution)

    def get_all_evaluators(self):
        try:
            with self.connection.cursor() as cursor:
                cursor.execute("""
                    SELECT DISTINCT evaluator
                    FROM evaluations
                    ORDER BY evaluator;
                """)
                results = cursor.fetchall()
                evaluators = [row[0] for row in results]
                self.logger.debug(f"Fetched evaluators: {evaluators}")
                return evaluators
        except Exception as e:
            self.logger.error(f"Error fetching evaluator names: {e}")
            return []

    def insert_entry(self, institution, event_number, data_json):
        try:
            with self.connection.cursor() as cursor:
                cursor.execute("""
                    INSERT INTO entries (institution, event_number, data)
                    VALUES (%s, %s, %s)
                    ON CONFLICT (institution, event_number) DO UPDATE
                    SET data = EXCLUDED.data;
                """, (institution, event_number, data_json))
                self.connection.commit()
                self.logger.debug(f"Inserted/Updated entry for event number {event_number} in institution {institution}.")
        except Exception as e:
            self.logger.error(f"Error inserting entry: {e}")
            raise e  # Reraise exception to be caught in the calling function


    def get_user_stats(self, evaluator_username, institution):
        try:
            with self.connection.cursor() as cursor:  # Define cursor within the method
                query = """
                    SELECT COUNT(*), AVG(summary_score), AVG(tag_score)
                    FROM evaluations
                    WHERE evaluator = %s AND LOWER(TRIM(institution)) = %s
                """
                cursor.execute(query, (evaluator_username, institution))
                result = cursor.fetchone()
                if result:
                    return {
                        'total_evaluations': result[0],
                        'average_summary_score': result[1],
                        'average_tag_score': result[2]
                    }
                else:
                    return {
                        'total_evaluations': 0,
                        'average_summary_score': 0,
                        'average_tag_score': 0
                    }
        except Exception as e:
            self.logger.error(f"Error fetching user stats for {evaluator_username}: {e}")
            return {
                'total_evaluations': 0,
                'average_summary_score': 0,
                'average_tag_score': 0
            }

================================================================================
File: ./institution_manager.py
================================================================================

import json
import logging

class InstitutionManager:
    """Manages institution data stored in Redis and PostgreSQL."""

    def __init__(self, redis_manager, postgres_manager):
        self.redis_manager = redis_manager
        self.postgres_manager = postgres_manager
        self.logger = logging.getLogger(__name__)

    def get_all_entries(self, institution):
        """Retrieve all entries for the institution from Redis."""
        try:
            entries = self.redis_manager.get_selected_entries(institution)
            return entries
        except Exception as e:
            self.logger.error(f"Failed to retrieve entries for {institution}: {e}")
            return []

    def update_entry(self, institution, updated_entry):
        """Update a single entry for the institution in Redis and PostgreSQL."""
        self.redis_manager.update_entry(institution, updated_entry)
        self.logger.info(f"Entry {updated_entry['Event Number']} for {institution} updated in Redis and PostgreSQL.")

    def get_selected_entries(self, institution):
        """Retrieve selected entries for the institution."""
        return self.redis_manager.get_selected_entries(institution)

    def get_evaluation_scores(self, institution):
        """Retrieve evaluation scores for the institution from Redis."""
        return self.redis_manager.get_evaluation_scores(institution)

    def reset_institution_data(self, institution):
        """Reset all data for an institution in both Redis and PostgreSQL."""
        try:
            # Reset Redis data
            self.redis_manager.reset_data(institution)
            self.logger.info(f"Redis data reset for institution {institution}")

            # Reset PostgreSQL data
            self.postgres_manager.reset_institution_data(institution)
            self.logger.info(f"PostgreSQL data reset for institution {institution}")

        except Exception as e:
            self.logger.error(f"Failed to reset data for institution {institution}: {e}")
            raise e

    def save_institution_data(self, institution, entries):
        """Save all entries for the institution in Redis and PostgreSQL."""
        self.redis_manager.save_selected_entries(institution, entries)
        self.logger.info(f"Data for {institution} has been saved in Redis and PostgreSQL.")

    def initialize_entries(self, institution, entries):
        """Initialize entries with default values and save them in Redis and PostgreSQL."""
        try:
            for entry in entries:
                entry.setdefault('Selected', 'Do Not Select')
                entry.setdefault('Evaluation', None)
                entry.setdefault('Assigned Tags', [])

            self.save_institution_data(institution, entries)
            self.logger.info(f"Initialized and saved entries for institution {institution}")
        except Exception as e:
            self.logger.error(f"Failed to initialize entries for institution {institution}: {e}")
            raise e

    def load_from_postgres(self, institution):
        """Load all entries and evaluation scores for the institution from PostgreSQL."""
        try:
            query_entries = """
            SELECT event_number, data FROM entries WHERE institution = %s;
            """
            query_scores = """
            SELECT evaluator, entry_number, summary_score, tag_score, feedback 
            FROM evaluations WHERE institution = %s;
            """
            with self.postgres_manager.connection.cursor() as cursor:
                cursor.execute(query_entries, (institution,))
                entries = cursor.fetchall()

                cursor.execute(query_scores, (institution,))
                evaluation_scores = cursor.fetchall()

            entries_dict = [json.loads(entry[1]) for entry in entries]
            evaluation_scores_dict = {}
            for score in evaluation_scores:
                evaluator, entry_number, summary_score, tag_score, feedback = score
                if entry_number not in evaluation_scores_dict:
                    evaluation_scores_dict[entry_number] = []
                evaluation_scores_dict[entry_number].append({
                    'Evaluator': evaluator,
                    'Summary Score': summary_score,
                    'Tag Score': tag_score,
                    'Feedback': feedback
                })

            return entries_dict, evaluation_scores_dict
        except Exception as e:
            self.logger.error(f"Error loading data from PostgreSQL for institution {institution}: {e}")
            return [], {}

================================================================================
File: ./selection_page.py
================================================================================

# selection_page.py

import streamlit as st
import random

class SelectionPage:
    def __init__(self, db_manager, institution):
        self.db_manager = db_manager
        self.institution = institution

    def show(self):
        st.header(f"Selection Mode - {self.institution}")

        # Use entries from session state or fetch from the database
        entries = st.session_state.get('all_entries', [])
        if not entries:
            entries = self.db_manager.get_selected_entries(self.institution)
            st.session_state['all_entries'] = entries

        total_entries = len(entries)

        # Add search input and filter options
        self.render_search_and_filters(entries)

        # Update total entries after filtering
        filtered_entries = self.get_filtered_entries(entries)
        total_filtered_entries = len(filtered_entries)

        if total_filtered_entries == 0:
            st.warning("No entries match the search and filter criteria.")
            return

        # Select random entries button
        self.select_random_entries(filtered_entries)

        # Initialize and bound the current index for entry navigation
        self.initialize_current_index(total_filtered_entries)

        # Display navigation and current entry
        self.display_navigation(filtered_entries, total_filtered_entries)

        # Display current entry details
        current_entry = filtered_entries[st.session_state.current_index]
        self.display_entry_details(current_entry, total_filtered_entries)

    def render_search_and_filters(self, entries):
        """Render search and filter options for selecting entries."""
        st.markdown("### Search and Filter Entries")

        # Search input
        st.text_input("Search by Narrative or Assigned Tags", key='selection_search_query')

        # Filter by Selection Status and Tags
        col1, col2 = st.columns(2)
        with col1:
            st.selectbox(
                "Filter by Selection Status",
                options=["All", "Selected", "Not Selected"],
                key='selection_filter'
            )
        with col2:
            all_tags = {tag.strip() for entry in entries for tag in entry.get('Assigned Tags', '').split(',') if tag.strip()}
            st.multiselect(
                "Filter by Assigned Tags",
                options=sorted(all_tags),
                key='tag_filter'
            )

    def get_filtered_entries(self, entries):
        """Filter entries based on search, selection, and tag criteria."""
        search_query = st.session_state.get('selection_search_query', '').lower()
        selection_filter = st.session_state.get('selection_filter', 'All')
        tag_filter = st.session_state.get('tag_filter', [])

        filtered_entries = entries

        # Apply search filter
        if search_query:
            filtered_entries = [
                entry for entry in filtered_entries
                if search_query in entry.get('Narrative', '').lower() or
                   search_query in entry.get('Assigned Tags', '').lower()
            ]

        # Apply selection filter
        if selection_filter != "All":
            status = 'Select for Evaluation' if selection_filter == "Selected" else 'Do Not Select'
            filtered_entries = [
                entry for entry in filtered_entries
                if entry.get('Selected', 'Do Not Select') == status
            ]

        # Apply tag filter
        if tag_filter:
            filtered_entries = [
                entry for entry in filtered_entries
                if any(tag.strip() in tag_filter for tag in entry.get('Assigned Tags', '').split(','))
            ]

        return filtered_entries

    def select_random_entries(self, filtered_entries):
        """Select 200 random entries from the filtered list."""
        if st.button("Select 200 Random Entries"):
            # Filter out unselected entries
            unselected_entries = [entry for entry in filtered_entries if entry.get('Selected', 'Do Not Select') == 'Do Not Select']
            num_to_select = min(200, len(unselected_entries))

            if num_to_select > 0:
                # Randomly select 200 entries from the unselected ones
                random_entries = random.sample(unselected_entries, num_to_select)
                for entry in random_entries:
                    entry['Selected'] = 'Select for Evaluation'

                # Batch update the selected entries in Redis and PostgreSQL
                self.db_manager.update_entries_batch(self.institution, random_entries)

                # Update session state
                for entry in random_entries:
                    for idx, e in enumerate(st.session_state['all_entries']):
                        if e['Event Number'] == entry['Event Number']:
                            st.session_state['all_entries'][idx]['Selected'] = 'Select for Evaluation'
                            break

                # Display a success message
                st.success(f"{num_to_select} random entries have been selected for evaluation.")
                st.rerun()  # Reload to reflect the changes
            else:
                st.warning("No unselected entries are available to select.")

    def initialize_current_index(self, total_filtered_entries):
        """Initialize and ensure current index is within bounds."""
        if 'current_index' not in st.session_state:
            st.session_state['current_index'] = 0

        # Ensure current_index is within bounds
        st.session_state['current_index'] = max(0, min(st.session_state['current_index'], total_filtered_entries - 1))

    def display_navigation(self, filtered_entries, total_filtered_entries):
        """Display entry navigation controls."""
        st.markdown("### Navigate Entries")

        col1, col2, col3 = st.columns([1, 2, 1])
        with col1:
            if st.button("Previous Entry") and st.session_state.current_index > 0:
                st.session_state.current_index -= 1
                st.rerun()
        with col3:
            if st.button("Next Entry") and st.session_state.current_index < total_filtered_entries - 1:
                st.session_state.current_index += 1
                st.rerun()
        with col2:
            st.session_state.current_index = st.slider(
                "Select Entry",
                min_value=1,
                max_value=total_filtered_entries,
                value=st.session_state.current_index + 1,
                format="Entry %d",
                key='entry_slider'
            ) - 1  # Adjust to 0-based index

        # Display progress bar
        st.progress((st.session_state.current_index + 1) / total_filtered_entries)

    def display_entry_details(self, current_entry, total_filtered_entries):
        """Display the details of the current entry."""
        entry_number_display = st.session_state.current_index + 1
        st.write(f"### Entry {entry_number_display} of {total_filtered_entries} - Event Number: {current_entry.get('Event Number', 'N/A')}")
        st.write(f"**Narrative:** {current_entry.get('Narrative', '')}")
        st.write(f"**Cleaned Narrative:** {current_entry.get('Cleaned Narrative', '')}")
        st.write(f"**Assigned Tags:** {current_entry.get('Assigned Tags', '')}")
        st.write(f"**Evaluation:** {current_entry.get('Evaluation', '')}")
        st.write(f"**Succinct Summary:** {current_entry.get('Succinct Summary', '')}")

        # Selection checkbox
        is_selected = current_entry.get('Selected', 'Do Not Select') == 'Select for Evaluation'
        selection = st.checkbox(
            "Select this entry for evaluation",
            value=is_selected,
            key=f"select_{current_entry.get('Event Number', st.session_state.current_index)}"
        )

        # Handle selection change
        if selection != is_selected:
            current_entry['Selected'] = 'Select for Evaluation' if selection else 'Do Not Select'
            self.update_entry_selection(current_entry)

        # Summary
        st.markdown(f"**Total Filtered Entries:** {total_filtered_entries}")
        st.markdown(f"**Total Entries in Database:** {len(st.session_state['all_entries'])}")

    def update_entry_selection(self, entry):
        """Update the selection status of an entry in both Redis and PostgreSQL."""
        self.db_manager.update_entry(self.institution, entry)

        # Update session state
        for idx, e in enumerate(st.session_state['all_entries']):
            if e['Event Number'] == entry['Event Number']:
                st.session_state['all_entries'][idx]['Selected'] = entry['Selected']
                break

================================================================================
File: ./analysis_methods.py
================================================================================

import json
import logging

# Set up logging for the analysis methods
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

def evaluate_entry(entry):
    """Evaluate a single entry and return a score based on specific criteria."""
    try:
        # Example evaluation logic; implement your actual calculation here
        score = len(entry.get('Narrative', '')) / 100  # Example scoring logic
        logger.info(f"Evaluated entry {entry.get('Event Number')}, score: {score}")
        return score
    except Exception as e:
        logger.error(f"Failed to evaluate entry: {e}")
        return None

def calculate_statistics(entries):
    """Calculate and return statistics from a list of entries."""
    try:
        total_entries = len(entries)
        total_score = sum(evaluate_entry(entry) for entry in entries if evaluate_entry(entry) is not None)
        average_score = total_score / total_entries if total_entries > 0 else 0
        logger.info(f"Calculated statistics: average score {average_score}, total entries {total_entries}")
        return {'average_score': average_score, 'total_entries': total_entries}
    except Exception as e:
        logger.error(f"Failed to calculate statistics: {e}")
        return {'average_score': 0, 'total_entries': 0}

def evaluate_and_tag_entries(entries):
    """Evaluate entries and tag them based on conditions."""
    try:
        evaluated_entries = []
        for entry in entries:
            # Remove auto-scoring logic and replace with tagging logic based on certain conditions.
            tags = []  # Add your custom logic for tagging based on other conditions if necessary
            # For example, you can create tags based on specific text in the narrative.
            if "critical" in entry.get('Narrative', '').lower():
                tags.append('Critical Incident')
            if "safety" in entry.get('Narrative', '').lower():
                tags.append('Safety Concern')
            
            entry['Tags'] = tags  # Only update tags, not the score
            evaluated_entries.append(entry)
        logger.info(f"Evaluated and tagged {len(evaluated_entries)} entries without automatic scoring.")
        return evaluated_entries
    except Exception as e:
        logger.error(f"Failed to evaluate and tag entries: {e}")
        return entries

def save_evaluation(self, evaluator, entry_number, institution, summary_score, tag_score, feedback):
    try:
        institution_clean = institution.strip().lower()
        with self.connection.cursor() as cursor:
            # Use UPSERT to insert or update the evaluation
            cursor.execute("""
                INSERT INTO evaluations (institution, evaluator, entry_number, summary_score, tag_score, feedback)
                VALUES (%s, %s, %s, %s, %s, %s)
                ON CONFLICT (institution, evaluator, entry_number)
                DO UPDATE SET summary_score = EXCLUDED.summary_score,
                              tag_score = EXCLUDED.tag_score,
                              feedback = EXCLUDED.feedback;
            """, (institution_clean, evaluator, entry_number, summary_score, tag_score, feedback))
        self.logger.debug(f"Saved evaluation for evaluator {evaluator}, entry {entry_number}.")
    except Exception as e:
        self.logger.error(f"Error saving evaluation for evaluator {evaluator}, entry {entry_number}: {e}")
        raise e

def evaluate_entry(entry):
    """Evaluate a single entry and return a score based on specific criteria."""
    # Removed scoring logic here since it should only happen from user input
    logger.info(f"Evaluated entry {entry.get('Event Number')} but no score assigned (user evaluation needed).")
    return None  # Return None since we are no longer auto-scoring

================================================================================
File: ./user_submission.py
================================================================================

import streamlit as st
import configparser
import logging
from database_manager import DatabaseManager
from login_manager import LoginManager

# Set up logging for debugging
logging.basicConfig(level=logging.WARNING)
logger = logging.getLogger(__name__)

# Load the configuration file
config = configparser.ConfigParser()
config.read('config.ini')

# Initialize PostgreSQL credentials
environment = 'home'
psql_host = config['postgresql'][f'psql_{environment}']
psql_port = config['postgresql'].getint('psql_port', 5432)
psql_user = config['postgresql']['psql_user']
psql_password = config['postgresql']['psql_password']
psql_dbname = config['postgresql']['psql_dbname']

# Initialize DatabaseManager and LoginManager
db_manager = DatabaseManager(
    psql_host=psql_host,
    psql_port=psql_port,
    psql_user=psql_user,
    psql_password=psql_password,
    psql_dbname=psql_dbname
)
login_manager = LoginManager()


# Check if evaluator is logged in
if not st.session_state.get('evaluator_logged_in', False):
    st.markdown("## Evaluator Login")
    evaluator_username = st.text_input("Username")
    evaluator_password = st.text_input("Password", type="password")

    if st.button("Login"):
        if login_manager.evaluator_login(st.session_state, evaluator_username, evaluator_password):
            st.success("Login successful!")
            st.session_state['current_eval_index'] = 0
            st.rerun()
        else:
            st.error("Invalid username or password")
else:
    # Evaluator is logged in
    evaluator_username = st.session_state['evaluator_username']
    evaluator_institution = st.session_state['evaluator_institution']

# Define the shared global enhancements and base styles for all institutions
    global_style = """
    <style>
        body, .stApp {
            background: linear-gradient(to bottom, #111111, #440000); /* Darker gradient */
            color: #f2f2f2; /* Light grey text for readability */
        }

        /* Typography enhancements */
        h1, h2, h3, h4, h5, h6 {
            font-family: 'Segoe UI', sans-serif;
        }

        .stProgress > div > div > div > div {
            background-color: #ff6666; /* Default progress bar color */
        }

        /* Box shadow for cards */
        .stTextArea, .stSlider, .stButton>button, .stRadio>div {
            box-shadow: 0px 4px 6px rgba(0,0,0,0.2); /* Subtle shadow */
            border-radius: 5px;
            margin: 10px 0px;
        }

        /* Button hover effect */
        .stButton>button:hover {
            background-color: #ff4d4d;
        }

        /* Padding for sections */
        .stMarkdown, .stTextArea, .stSlider {
            padding: 10px;
            border-radius: 8px;
            background-color: rgba(255, 255, 255, 0.1); /* Slight translucency */
        }

        h1 {
            text-align: center;
            margin-top: 10px;
        }

        .logo-container {
            display: flex;
            justify-content: center;
            margin-bottom: 10px;
            padding: 20px 0;
            border-bottom: 1px solid #ff6666;
        }
    </style>
    """

    # Define institution-specific styles
    mbpcc_style = """
    <style>
        body, .stApp {
            background: linear-gradient(to bottom, #1a1a1a, #800000); /* Dark red for MBPCC */
            color: #f2f2f2;
        }
        h1, h2, h3, h4, h5, h6 {
            color: #ff4d4d; /* Red headers for MBPCC */
        }
        .stButton>button {
            background-color: #ff1a1a;
            color: #000000;
        }
        .stProgress > div > div > div > div {
            background-color: #ff4d4d; /* Red progress bar for MBPCC */
        }
    </style>
    """

    uab_style = """
    <style>
        body, .stApp {
            background: linear-gradient(to bottom, #0d1b0e, #003300); /* Dark green for UAB */
            color: #e6e6e6;
        }
        h1, h2, h3, h4, h5, h6 {
            color: #ffcc00; /* UAB Gold for headers */
        }
        .stButton>button {
            background-color: #ffcc00;
            color: #003300;
        }
        .stProgress > div > div > div > div {
            background-color: #ffcc00; /* UAB Gold progress bar */
        }
    </style>
    """

    # Apply the global styling
    st.markdown(global_style, unsafe_allow_html=True)

    # Apply institution-specific styling based on the user's institution
    if evaluator_institution.lower() == 'uab':
        st.markdown(uab_style, unsafe_allow_html=True)
    elif evaluator_institution.lower() == 'mbpcc':
        st.markdown(mbpcc_style, unsafe_allow_html=True)

    # Apply institution-specific styling and load logo path
    logo_path = ""
    if evaluator_institution.lower() == 'uab':
        logo_path = "resources/UAB.png"  # Ensure this path is correct
    elif evaluator_institution.lower() == 'mbpcc':
        logo_path = "resources/MBPCC.png"  # Ensure this path is correct

    # Streamlit UI with logo above the title (Option 2)
    if logo_path:
        try:
            col1, col2, col3 = st.columns([1, 2, 1])  # Three columns to center the logo
            with col2:
                st.image(logo_path, width=200, use_column_width=False)
        except Exception as e:
            st.error(f"Failed to load logo. Error: {e}")

    # Title placed below the logo
    st.title("Evaluator Dashboard")

    # Add a Refresh Data button
    if st.button("Refresh Data"):
        st.session_state.pop('assigned_entries', None)
        st.session_state.pop('total_assigned_entries', None)
        st.session_state.pop('current_eval_index', None)
        st.session_state.pop('re_evaluating', None)
        st.rerun()

    # Page navigation
    page_selection = st.radio("Choose Page", ["Evaluation Submission", "Progress & Statistics"])

    if page_selection == "Evaluation Submission":
        st.markdown(f"### Welcome, {evaluator_username}!")

        # Load assigned entries if not already in session state
        if 'assigned_entries' not in st.session_state:
            assigned_entries = db_manager.get_selected_entries(evaluator_institution)
            assigned_entries = [entry for entry in assigned_entries if entry.get('Selected') == 'Select for Evaluation']
            st.session_state['assigned_entries'] = assigned_entries
            st.session_state['total_assigned_entries'] = len(assigned_entries)

        assigned_entries = st.session_state.get('assigned_entries', [])
        total_assigned_entries = st.session_state.get('total_assigned_entries', 0)

        if total_assigned_entries == 0:
            st.write("No entries assigned for evaluation.")
        else:
            # Navigate to first un-evaluated entry upon login
            if 'first_unrated' not in st.session_state:
                for i, entry in enumerate(assigned_entries):
                    event_number = entry.get('Event Number', '')
                    if not db_manager.get_evaluation(evaluator_username, event_number, evaluator_institution):
                        st.session_state['current_eval_index'] = i
                        break
                st.session_state['first_unrated'] = True

            # Ensure index is within bounds
            current_eval_index = st.session_state.get('current_eval_index', 0)
            if current_eval_index >= total_assigned_entries:
                current_eval_index = total_assigned_entries - 1
            if current_eval_index < 0:
                current_eval_index = 0

            current_entry = assigned_entries[current_eval_index]

            # Navigation tools (you can keep this as needed)
            col1, col2, col3 = st.columns([1, 2, 1])
            with col1:
                if st.button("Previous Entry") and current_eval_index > 0:
                    st.session_state['current_eval_index'] -= 1
                    st.rerun()
            with col3:
                if st.button("Next Entry") and current_eval_index < total_assigned_entries - 1:
                    st.session_state['current_eval_index'] += 1
                    st.rerun()

            # Display progress bar
            st.progress((current_eval_index + 1) / total_assigned_entries)

            # Display the current entry for evaluation
            st.write(f"### Entry {current_eval_index + 1} of {total_assigned_entries} - Event Number: {current_entry.get('Event Number', 'N/A')}")
            st.markdown("#### Original Narrative")
            st.write(current_entry.get('Narrative', ''))

            st.markdown("#### Succinct Summary")
            st.write(current_entry.get('Succinct Summary', ''))

            # Check if the evaluator has already evaluated this entry
            evaluator_previous_evaluation = db_manager.get_evaluation(
                evaluator_username,
                current_entry.get('Event Number', ''),
                evaluator_institution
            )

            # Use unique keys for each component to avoid conflicts
            summary_score_key = f"summary_score_{current_eval_index}"
            tag_score_key = f"tag_score_{current_eval_index}"
            feedback_key = f"evaluation_feedback_{current_eval_index}"

            st.markdown("#### Assigned Tags")
            st.write(current_entry.get('Assigned Tags', ''))

            # If evaluated, show scores and allow re-evaluation
            if evaluator_previous_evaluation and not st.session_state.get('re_evaluating', False):
                st.markdown("### This entry has already been evaluated by you.")
                st.write(f"**Summary Score:** {evaluator_previous_evaluation['summary_score']}")
                st.write(f"**Tag Score:** {evaluator_previous_evaluation['tag_score']}")
                st.write(f"**Feedback:** {evaluator_previous_evaluation['feedback']}")

                if st.button("Edit Evaluation"):
                    st.session_state['re_evaluating'] = True
                    st.rerun()
            else:
                # Get scores from session state or use default
                summary_score = st.session_state.get(summary_score_key, 3)
                tag_score = st.session_state.get(tag_score_key, 3)
                feedback = st.session_state.get(feedback_key, '')

                # Display sliders for input
                summary_score = st.slider("Rate the Succinct Summary (1-5)", min_value=1, max_value=5, value=summary_score, key=summary_score_key)
                tag_score = st.slider("Rate the Assigned Tags (1-5)", min_value=1, max_value=5, value=tag_score, key=tag_score_key)
                feedback = st.text_area("Feedback", value=feedback, key=feedback_key)

                # Submit button
                if st.button("Submit Evaluation"):
                    is_new_evaluation = evaluator_previous_evaluation is None

                    try:
                        # Save evaluation to the database
                        db_manager.save_evaluation(
                            evaluator_username,
                            current_entry.get('Event Number', ''),
                            evaluator_institution,
                            summary_score,
                            tag_score,
                            feedback
                        )

                        # Update institution statistics
                        old_summary_score = evaluator_previous_evaluation['summary_score'] if evaluator_previous_evaluation else 0
                        old_tag_score = evaluator_previous_evaluation['tag_score'] if evaluator_previous_evaluation else 0
                        db_manager.update_institution_stats(
                            evaluator_institution,
                            summary_score,
                            tag_score,
                            is_new_evaluation,
                            old_summary_score,
                            old_tag_score
                        )

                        # Success message
                        st.success("Your evaluation has been submitted.")

                        # Automatically move to the next entry
                        if current_eval_index < total_assigned_entries - 1:
                            st.session_state['current_eval_index'] += 1
                        else:
                            st.success("You have completed all assigned evaluations.")
                        st.rerun()
                    except Exception as e:
                        logger.error(f"Error saving evaluation: {e}")
                        st.error("An error occurred while saving your evaluation. Please try again.")

    elif page_selection == "Progress & Statistics":
        st.markdown(f"### Progress for {evaluator_username}")

        # Force refresh the assigned entries and completed evaluations from the database
        assigned_entries = db_manager.get_selected_entries(evaluator_institution)

        # Filter assigned entries
        filtered_assigned_entries = [entry for entry in assigned_entries if entry.get('Selected') == 'Select for Evaluation']
        st.session_state['assigned_entries'] = filtered_assigned_entries

        completed_evaluations = db_manager.count_evaluations_by_evaluator(evaluator_username, evaluator_institution)
        st.session_state['completed_evaluations'] = completed_evaluations

        # Display the correct count for assigned entries (should reflect 200 for kkirby)
        st.write(f"Entries Assigned: {len(filtered_assigned_entries)}")  # Now correctly counts only the 200 assigned entries
        st.write(f"Evaluations Completed: {completed_evaluations}")
        st.progress(completed_evaluations / len(filtered_assigned_entries) if filtered_assigned_entries else 0)

        # Fetch and display the user's average score if available
        user_stats = db_manager.get_user_stats(evaluator_username, evaluator_institution)

        if user_stats['total_evaluations'] > 0:
            avg_user_summary = user_stats['cumulative_summary'] / user_stats['total_evaluations']
            avg_user_tag = user_stats['cumulative_tag'] / user_stats['total_evaluations']
            st.metric("Your Average Summary Score", f"{avg_user_summary:.2f}")
            st.metric("Your Average Tag Score", f"{avg_user_tag:.2f}")
        else:
            st.write("You have not evaluated enough entries for an average score yet.")

        # Display institution statistics
        st.markdown(f"### {evaluator_institution} Statistics")

        stats = db_manager.get_institution_stats(evaluator_institution)

        if stats['total_evaluations'] > 0:
            avg_summary = stats['cumulative_summary'] / stats['total_evaluations']
            avg_tag = stats['cumulative_tag'] / stats['total_evaluations']
            st.write(f"Total Evaluations: {stats['total_evaluations']}")
            st.metric("Average Summary Score (Institution)", f"{avg_summary:.2f}")
            st.metric("Average Tag Score (Institution)", f"{avg_tag:.2f}")
        else:
            st.write("No evaluations found for this institution.")

        # Add scrollable list of entries for navigation
        st.markdown("### Jump to an Entry")

        # Use the correct key references for each entry in 'filtered_assigned_entries'
        scrollable_entries = st.selectbox(
            "Select an Entry to Jump To",
            options=[f"Entry {i+1} - {entry.get('Event Number', 'N/A')} {'' if db_manager.get_evaluation(evaluator_username, entry.get('Event Number', ''), evaluator_institution) else ''}" for i, entry in enumerate(filtered_assigned_entries)],
            index=st.session_state.get('current_eval_index', 0)
        )

        selected_entry_index = int(scrollable_entries.split()[1]) - 1  # Extract index from selected entry
        st.session_state['current_eval_index'] = selected_entry_index

        # Display selected entry details (narrative, tags, scores, etc.)
        selected_entry = filtered_assigned_entries[selected_entry_index]
        st.markdown("#### Original Narrative")
        st.write(selected_entry.get('Narrative', ''))

        st.markdown("#### Assigned Tags")
        st.write(selected_entry.get('Assigned Tags', ''))

        # Check if this entry has been evaluated
        evaluator_previous_evaluation = db_manager.get_evaluation(
            evaluator_username,
            selected_entry.get('Event Number', ''),
            evaluator_institution
        )

        if evaluator_previous_evaluation:
            st.markdown("### Evaluation Scores")
            st.write(f"**Summary Score:** {evaluator_previous_evaluation['summary_score']}")
            st.write(f"**Tag Score:** {evaluator_previous_evaluation['tag_score']}")
            st.write(f"**Feedback:** {evaluator_previous_evaluation['feedback']}")

            # Fix the StreamlitDuplicateElementId error by providing a unique key for the radio button
            if st.button("Re-evaluate Entry"):
                st.session_state['current_eval_index'] = selected_entry_index
                st.session_state['re_evaluating'] = True
                st.radio("Choose Page", ["Evaluation Submission", "Progress & Statistics"], index=0, key='re_eval_page')  # Unique key provided here
                st.rerun()
        else:
            st.write("This entry has not been evaluated yet.")







        # Logout button
        if st.button("Logout"):
            login_manager.logout(st.session_state)
            st.session_state['evaluator_logged_in'] = False
            st.rerun()


================================================================================
File: ./Archive/user_submission.py
================================================================================

# user_submission.py

import streamlit as st
import pandas as pd
import numpy as np
from login_manager import LoginManager
from institution_manager import InstitutionManager
from redis_manager import RedisManager
from network_resolver import NetworkResolver
import configparser
import logging

# Set up logging
logging.basicConfig(level=logging.INFO)

# Load configuration
config = configparser.ConfigParser()
config.read('config.ini')

# Initialize the NetworkResolver
resolver = NetworkResolver(config)

# Resolve Redis host
redis_host = resolver.resolve_host()
redis_port = config['Redis'].getint('redis_port', 6379)
redis_manager = RedisManager(redis_host, redis_port)

# Initialize the InstitutionManager
institution_manager = InstitutionManager(redis_manager)

# Initialize the LoginManager
login_manager = LoginManager()

# Streamlit UI
st.title("Evaluator Dashboard")

# Check if evaluator is logged in
if not st.session_state.get('evaluator_logged_in', False):
    st.markdown("## Evaluator Login")
    evaluator_username = st.text_input("Username")
    evaluator_password = st.text_input("Password", type="password")

    if st.button("Login"):
        if login_manager.evaluator_login(st.session_state, evaluator_username, evaluator_password):
            st.success("Login successful!")
            st.experimental_rerun()
        else:
            st.error("Invalid username or password")
else:
    # Evaluator is logged in
    st.markdown(f"### Welcome, {st.session_state['evaluator_username']}!")

    # Select Institution
    institution = st.selectbox(
        "Select Institution", ["UAB", "MBPCC"],
        key='evaluator_institution_select',
    )

    # Load assigned entries
    if 'assigned_entries' not in st.session_state:
        # For simplicity, assign all selected entries to the evaluator
        all_entries, _ = institution_manager.get_institution_data(institution)
        assigned_entries = [
            entry for entry in all_entries if entry.get('Selected') == 'Select for Evaluation'
        ]
        st.session_state['assigned_entries'] = assigned_entries
        st.session_state['total_assigned_entries'] = len(assigned_entries)
    else:
        assigned_entries = st.session_state['assigned_entries']

    total_assigned_entries = st.session_state.get('total_assigned_entries', 0)

    if total_assigned_entries == 0:
        st.write("No entries assigned for evaluation.")
    else:
        # Initialize current evaluation index
        if 'current_eval_index' not in st.session_state:
            st.session_state['current_eval_index'] = 0

        # Ensure index is within bounds
        if st.session_state.current_eval_index >= total_assigned_entries:
            st.session_state.current_eval_index = total_assigned_entries - 1
        if st.session_state.current_eval_index < 0:
            st.session_state.current_eval_index = 0

        # Navigation
        st.markdown("### Navigate Entries")
        col1, col2, col3 = st.columns([1, 2, 1])
        with col1:
            if st.button("Previous Entry") and st.session_state.current_eval_index > 0:
                st.session_state.current_eval_index -= 1
        with col2:
            # Slider to navigate entries (enumerated from 1)
            st.session_state.current_eval_index = st.slider(
                "Select Entry",
                min_value=1,
                max_value=total_assigned_entries,
                value=st.session_state.current_eval_index + 1,
                format="Entry %d",
                key='eval_entry_slider'
            ) - 1  # Adjust index to be 0-based
        with col3:
            if st.button("Next Entry") and st.session_state.current_eval_index < total_assigned_entries - 1:
                st.session_state.current_eval_index += 1

        current_entry = assigned_entries[st.session_state.current_eval_index]

        # Display progress bar or visual indicator
        progress = (st.session_state.current_eval_index + 1) / total_assigned_entries
        st.progress(progress)

        # Display the current entry
        st.write(f"### Entry {st.session_state.current_eval_index + 1} of {total_assigned_entries} - Event Number: {current_entry.get('Event Number', 'N/A')}")

        st.markdown("#### Original Narrative")
        st.write(current_entry.get('Narrative', ''))

        st.markdown("#### Succinct Summary")
        st.write(current_entry.get('Succinct Summary', ''))
        summary_score = st.slider("Rate the Succinct Summary (1-5)", min_value=1, max_value=5, key='summary_score', value=3)

        st.markdown("#### Assigned Tags")
        st.write(current_entry.get('Assigned Tags', ''))
        tag_score = st.slider("Rate the Assigned Tags (1-5)", min_value=1, max_value=5, key='tag_score', value=3)

        st.markdown("#### Provide Your Feedback")
        feedback = st.text_area("Feedback", key='evaluation_feedback', value='')

        if st.button("Submit Evaluation"):
            # Save evaluation
            evaluation = {
                'Evaluator': st.session_state['evaluator_username'],
                'Summary Score': summary_score,
                'Tag Score': tag_score,
                'Feedback': feedback
            }
            # Add evaluation to the entry
            if 'Evaluations' not in current_entry:
                current_entry['Evaluations'] = []
            current_entry['Evaluations'].append(evaluation)

            # Update entry in Redis
            institution_manager.update_entry(institution, current_entry)

            # Update session state
            st.session_state['assigned_entries'][st.session_state.current_eval_index] = current_entry

            # Update institution statistics in Redis
            # Use a Redis hash to store cumulative sums and counts
            stats_key = f"{institution}_stats"

            # Get existing stats or initialize them
            existing_stats = redis_manager.redis_client.hgetall(stats_key)
            if existing_stats:
                cumulative_summary = float(existing_stats.get('cumulative_summary', 0))
                cumulative_tag = float(existing_stats.get('cumulative_tag', 0))
                total_evaluations = int(existing_stats.get('total_evaluations', 0))
            else:
                cumulative_summary = 0.0
                cumulative_tag = 0.0
                total_evaluations = 0

            # Update stats
            cumulative_summary += summary_score
            cumulative_tag += tag_score
            total_evaluations += 1

            # Save updated stats back to Redis
            redis_manager.redis_client.hmset(stats_key, {
                'cumulative_summary': cumulative_summary,
                'cumulative_tag': cumulative_tag,
                'total_evaluations': total_evaluations
            })

            st.success("Evaluation submitted successfully!")

            # Reset input widgets by resetting their keys
            st.session_state['summary_score'] = 3  # Default value
            st.session_state['tag_score'] = 3
            st.session_state['evaluation_feedback'] = ''

            # Move to the next entry
            if st.session_state.current_eval_index < total_assigned_entries - 1:
                st.session_state.current_eval_index += 1
                st.experimental_rerun()  # Refresh the page to show the next entry
            else:
                st.success("You have completed all assigned evaluations.")
                # Optionally, reset the index to start over or disable further input

        # Logout button
        if st.button("Logout"):
            st.session_state['evaluator_logged_in'] = False
            st.session_state.pop('assigned_entries', None)
            st.session_state.pop('current_eval_index', None)
            st.success("Logged out successfully!")
            st.experimental_rerun()

================================================================================
File: ./Archive/redis_manager.py
================================================================================

# redis_manager.py
      
import redis
import json
import logging
from postgres_manager import PostgresManager

class RedisManager:
    """Manages Redis operations for selected entries and evaluation scores."""
    
    def __init__(self, host, port, postgres_manager):
        self.redis_client = redis.StrictRedis(
            host=host, port=port, db=0, decode_responses=True
        )
        self.postgres_manager = postgres_manager  # Store PostgresManager
        self.logger = logging.getLogger(__name__)

    def get_selected_entries(self, institution):
        """Retrieve selected entries for a specific institution."""
        try:
            entries_json = self.redis_client.get(f"{institution}:selected_entries")
            if entries_json:
                entries = json.loads(entries_json)
                self.logger.info(f"Entries successfully retrieved from Redis for {institution}.")
                return entries
            else:
                # Fallback to PostgreSQL if Redis is unavailable
                self.logger.warning(f"Redis is empty, falling back to PostgreSQL for {institution}.")
                return self.postgres_manager.get_selected_entries(institution)
        except Exception as e:
            self.logger.error(f"Error retrieving selected entries for {institution}: {e}")
            return []


    def update_entry(self, institution, updated_entry):
        """Update a single entry for the institution in Redis and PostgreSQL."""
        try:
            # Fetch and update entries from Redis or PostgreSQL
            entries = self.get_selected_entries(institution)

            # Update or append the entry
            for idx, entry in enumerate(entries):
                if entry['Event Number'] == updated_entry['Event Number']:
                    entries[idx] = updated_entry
                    break
            else:
                entries.append(updated_entry)

            # Save back to Redis and PostgreSQL
            self.save_selected_entries(institution, entries)
            self.logger.info(f"Entry {updated_entry['Event Number']} for {institution} updated successfully.")
        except Exception as e:
            self.logger.error(f"Failed to update entry {updated_entry['Event Number']} for {institution}: {e}")
            raise e

    def save_selected_entries(self, institution, selected_entries):
        """Save selected entries for a specific institution to Redis and PostgreSQL."""
        try:
            entries_json = json.dumps(selected_entries)
            self.redis_client.set(f"{institution}:selected_entries", entries_json)
            self.postgres_manager.save_selected_entries(institution, selected_entries)
            self.logger.info(f"Selected entries for {institution} saved to Redis and PostgreSQL.")
        except Exception as e:
            self.logger.error(f"Failed to save selected entries for {institution}: {e}")


    def get_evaluation_scores(self, institution):
        """Retrieve evaluation scores for a specific institution."""
        try:
            scores_json = self.redis_client.get(f"{institution}:evaluation_scores")
            if scores_json:
                return json.loads(scores_json)
            else:
                # Fallback to PostgreSQL if Redis is unavailable
                self.logger.warning(f"Failed to fetch from Redis, falling back to PostgreSQL for {institution}.")
                return self.postgres_manager.get_evaluation_scores(institution)
        except Exception as e:
            self.logger.error(f"Error retrieving evaluation scores for {institution}: {e}")
            return {}

    def save_evaluation_scores(self, institution, evaluation_scores):
        """Save evaluation scores for a specific institution."""
        try:
            scores_json = json.dumps(evaluation_scores)
            self.redis_client.set(f"{institution}:evaluation_scores", scores_json)
            # Also save to PostgreSQL for backup
            self.postgres_manager.save_evaluation_scores(institution, evaluation_scores)
        except Exception as e:
            self.logger.error(f"Failed to save evaluation scores for {institution}: {e}")

    def reset_data(self, institution):
        """Reset selected entries and evaluation scores for a specific institution."""
        try:
            self.redis_client.delete(f"{institution}:selected_entries")
            self.redis_client.delete(f"{institution}:evaluation_scores")
            # Also reset the data in PostgreSQL
            self.postgres_manager.reset_data(institution)
            self.logger.info(f"Data for {institution} has been reset.")
        except Exception as e:
            self.logger.error(f"Failed to reset data for {institution}: {e}")

    def update_institution_stats(self, institution, summary_score, tag_score, is_new_evaluation=True, old_summary_score=0, old_tag_score=0):
        """Update the cumulative statistics for an institution."""
        stats_key = f"{institution}_stats"

        # Use Redis transactions to ensure atomic updates
        with self.redis_client.pipeline() as pipe:
            while True:
                try:
                    # Watch the stats_key
                    pipe.watch(stats_key)

                    # Get existing stats or initialize them
                    existing_stats = pipe.hgetall(stats_key)
                    if existing_stats:
                        cumulative_summary = float(existing_stats.get('cumulative_summary', 0))
                        cumulative_tag = float(existing_stats.get('cumulative_tag', 0))
                        total_evaluations = int(existing_stats.get('total_evaluations', 0))
                    else:
                        cumulative_summary = 0.0
                        cumulative_tag = 0.0
                        total_evaluations = 0

                    # Adjust stats
                    cumulative_summary = cumulative_summary - old_summary_score + summary_score
                    cumulative_tag = cumulative_tag - old_tag_score + tag_score

                    if is_new_evaluation:
                        total_evaluations += 1
                    # If it's an update, total_evaluations remains the same

                    # Start transaction
                    pipe.multi()

                    # Save updated stats back to Redis
                    pipe.hmset(stats_key, {
                        'cumulative_summary': cumulative_summary,
                        'cumulative_tag': cumulative_tag,
                        'total_evaluations': total_evaluations
                    })

                    # Execute transaction
                    pipe.execute()

                    # Also save institution stats in PostgreSQL
                    self.postgres_manager.update_institution_stats(
                        institution, cumulative_summary, cumulative_tag, total_evaluations
                    )

                    break
                except redis.WatchError:
                    # If WatchError is raised, it means that the watched key was modified
                    continue  # Retry the transaction

    def get_institution_stats(self, institution):
        """Retrieve the cumulative statistics for an institution."""
        stats_key = f"{institution}_stats"
        try:
            stats = self.redis_client.hgetall(stats_key)
            if stats:
                return {
                    'cumulative_summary': float(stats.get('cumulative_summary', 0)),
                    'cumulative_tag': float(stats.get('cumulative_tag', 0)),
                    'total_evaluations': int(stats.get('total_evaluations', 0))
                }
            else:
                # Fallback to PostgreSQL if Redis data is not available
                return self.postgres_manager.get_institution_stats(institution)
        except Exception as e:
            self.logger.error(f"Failed to get institution stats for {institution}: {e}")
            return {
                'cumulative_summary': 0.0,
                'cumulative_tag': 0.0,
                'total_evaluations': 0
            }


class RedisSnapshotManager:
    """Manages snapshots of Redis data for institutions."""
    
    def __init__(self, redis_client):
        self.redis_client = redis_client
        self.logger = logging.getLogger(__name__)

    def take_snapshot(self, institution):
        """Take a snapshot of data for a specific institution and store it."""
        try:
            # Retrieve and serialize current data for the institution
            selected_entries_json = self.redis_client.get(f"{institution}:selected_entries")
            evaluation_scores_json = self.redis_client.get(f"{institution}:evaluation_scores")

            selected_entries = json.loads(selected_entries_json) if selected_entries_json else []
            evaluation_scores = json.loads(evaluation_scores_json) if evaluation_scores_json else {}

            # Prepare snapshot data
            snapshot_data = {
                'selected_entries': selected_entries,
                'evaluation_scores': evaluation_scores
            }

            # Save the snapshot in Redis
            snapshot_json = json.dumps(snapshot_data)
            snapshot_key = f"{institution}:snapshot"
            self.redis_client.set(snapshot_key, snapshot_json)
            self.logger.info(f"Snapshot for {institution} saved successfully.")

        except Exception as e:
            self.logger.error(f"Failed to take snapshot for {institution}: {e}")
            st.error(f"Failed to take snapshot for {institution}. Please check logs for details.")

    def load_snapshot(self, institution):
        """Load a previously taken snapshot for a specific institution."""
        try:
            # Retrieve the snapshot
            snapshot_key = f"{institution}:snapshot"
            snapshot_json = self.redis_client.get(snapshot_key)

            if snapshot_json:
                # Deserialize the snapshot data
                snapshot_data = json.loads(snapshot_json)

                # Restore the data for the specific institution
                self.redis_client.set(f"{institution}:selected_entries", json.dumps(snapshot_data['selected_entries']))
                self.redis_client.set(f"{institution}:evaluation_scores", json.dumps(snapshot_data['evaluation_scores']))
                self.logger.info(f"Snapshot for {institution} loaded successfully.")
            else:
                self.logger.warning(f"No snapshot found for {institution}.")
                st.warning(f"No snapshot found for {institution}.")

        except Exception as e:
            self.logger.error(f"Failed to load snapshot for {institution}: {e}")
            st.error(f"Failed to load snapshot for {institution}. Please check logs for details.")


# Function to reset institution data within your Streamlit app
def reset_institution(institution, institution_manager):
    """Resets the data for the given institution and updates the session state."""
    with st.spinner(f"Resetting data for {institution}. Please wait..."):
        # Reset entries and evaluations for the institution
        institution_manager.reset_data(institution)

        # Also reset cumulative statistics for the institution
        stats_key = f"{institution}_stats"
        redis_client = institution_manager.redis_manager.redis_client
        redis_client.delete(stats_key)  # Clear stats

        sleep(1)  # Simulate time taken for Redis operation

        # Clear session state related to the institution
        st.session_state.pop('selected_entries', None)
        st.session_state.pop('total_entries', None)
        st.session_state.pop('current_index', None)
        st.success(f"All data for {institution} has been reset.")

================================================================================
File: ./Archive/institution_manager.py
================================================================================

# institution_manager.py

import json
import logging

class InstitutionManager:
    """Manages institution data stored in Redis."""

    def __init__(self, redis_manager):
        self.redis_manager = redis_manager
        self.redis_client = redis_manager.redis_client
        self.logger = logging.getLogger(__name__)

    def get_all_entries(self, institution):
        """Retrieve all entries for the institution."""
        entries_json = self.redis_client.get(f"{institution}:entries")
        if entries_json:
            try:
                entries = json.loads(entries_json)
                return entries
            except json.JSONDecodeError as e:
                self.logger.error(f"JSON decode error for all entries: {e}")
                return []
        else:
            return []

    def get_selected_entries(self, institution):
        """Retrieve selected entries for the institution."""
        all_entries = self.get_all_entries(institution)
        selected_entries = [entry for entry in all_entries if entry.get('Selected') == 'Select for Evaluation']
        return selected_entries

    def get_evaluation_scores(self, institution):
        """Retrieve evaluation scores for a specific institution."""
        scores_json = self.redis_client.get(f"{institution}:evaluation_scores")
        if scores_json:
            try:
                scores = json.loads(scores_json)
                return scores
            except json.JSONDecodeError as e:
                self.logger.error(f"JSON decode error for evaluation scores: {e}")
                return {}
        else:
            return {}

    def get_institution_data(self, institution):
        """Retrieve all entries and evaluation scores for the institution."""
        all_entries = self.get_all_entries(institution)
        evaluation_scores = self.get_evaluation_scores(institution)
        return all_entries, evaluation_scores

    def save_institution_data(self, institution, entries):
        """Save all entries for the institution."""
        try:
            entries_json = json.dumps(entries)
            self.redis_client.set(f"{institution}:entries", entries_json)
        except Exception as e:
            self.logger.error(f"Failed to save institution data: {e}")

    def reset_institution_data(self, institution):
        """Reset all data for the institution in Redis."""
        try:
            self.redis_client.delete(f"{institution}:entries")
            self.redis_client.delete(f"{institution}:evaluation_scores")
            self.logger.info(f"Data for {institution} has been reset in Redis.")
        except Exception as e:
            self.logger.error(f"Failed to reset data for {institution} in Redis: {e}")

    def update_entry(self, institution, updated_entry):
        """Update a single entry for the institution."""
        try:
            entries = self.get_all_entries(institution)
            for idx, entry in enumerate(entries):
                if entry['Event Number'] == updated_entry['Event Number']:
                    entries[idx] = updated_entry
                    break
            else:
                # Entry not found, add it
                entries.append(updated_entry)
            self.save_institution_data(institution, entries)
        except Exception as e:
            self.logger.error(f"Failed to update entry: {e}")

    def update_selection(self, institution, event_number, selection_status):
        """Update the selection status of a specific entry."""
        try:
            entries = self.get_all_entries(institution)
            for entry in entries:
                if entry['Event Number'] == event_number:
                    entry['Selected'] = selection_status
                    break
            self.save_institution_data(institution, entries)
        except Exception as e:
            self.logger.error(f"Failed to update selection: {e}")

    def initialize_entries(self, institution, entries):
        """Initialize entries with default values if necessary and save them."""
        for entry in entries:
            entry.setdefault('Selected', 'Do Not Select')
            entry.setdefault('Evaluation', None)
            entry.setdefault('Assigned Tags', [])
        self.save_institution_data(institution, entries)

================================================================================
File: ./Archive/login_manager.py
================================================================================

# login_manager.py

class LoginManager:
    def __init__(self):
        # Admin credentials
        self.admin_credentials = {
            'admin_username': 'admin',
            'admin_password': 'admin_password'
        }
        # Evaluator credentials
        self.evaluator_credentials = {
            'evaluator1': 'password1',
            'evaluator2': 'password2',
            # Add more evaluators as needed
        }


    def login(self, session_state, username, password):
        if username == self.admin_credentials['admin_username'] and password == self.admin_credentials['admin_password']:
            session_state['user_role'] = 'admin'
            return True
        else:
            return False


    def evaluator_login(self, session_state, username, password):
        if username in self.evaluator_credentials:
            if self.evaluator_credentials[username] == password:
                session_state['evaluator_logged_in'] = True
                session_state['evaluator_username'] = username
                session_state['user_role'] = 'evaluator'
                return True
            else:
                return False
        else:
            return False


    def logout(self, session_state):
        session_state.pop('user_role', None)

================================================================================
File: ./Archive/config.ini
================================================================================

[API]
endpoint_home = http://192.168.1.5:11434/api/generate
endpoint_work = http://172.30.98.11:11434/api/generate

[Redis]
host_home = 192.168.1.4
host_work = 172.30.98.46
redis_port = 6379

[Summary_Model]
name = mistral
num_predict = 500
top_k = 15
top_p = 0.2
temperature = 0.01
num_ctx = 16000
prompt = "Task Objective: Produce a succinct and accurate summary of the event detailed below, reflecting only the information presented. Start the summary on a new line, immediately without spaces, and avoid unnecessary blank lines. Narrative: '{narrative}' Begin Summary:"

[Eval_Model]
name = mixtral
num_predict = 500
top_k = 10
top_p = 0.15
temperature = 0.01
num_ctx = 32000
prompt = "Based on the narrative and summary provided, please generate an evaluation. Start your evaluation with the word 'Grade:' followed by one of the following grades: 'Identical', 'Similar', 'Dissimilar', 'Irrelevant'. After the grade, provide a brief explanation of your grading decision. Here is the narrative: '{narrative}'. Here is the summary: '{summary}'. For example, a correct evaluation might be: 'Grade: Identical. The summary perfectly captures all the points in the narrative, using different words but conveying the same meaning. Do not deviate from this format'"

[Expert_Model]
name = mixtral
num_predict = 500
top_k = 15
top_p = 0.25
temperature = 0.01
num_ctx = 32000
prompt = "As a medical physicist, analyze the following patient case from an incident learning system. User Submitted Entry: '[mistral Summary]'. Cleaned Summary: '[Cleaned Summary]'. Processed Text: '[Processed Text]'. Identify any clinical issues, errors, or noteworthy patterns and list them as numbered points. For each identified issue, provide a list of suggested tags. The tags should be relevant, specific, consistent, brief, and comprehensive. The tags should be keywords or concepts relevant to the text and the field of radiation oncology, and limited to no more than 7 words. Please provide the tags in the following format: 'Suggested Tags: tag1, tag2, tag3, etc.'"

[Succinctor_Model]
name = mistral:latest
num_predict = 200
min_predict = 50
predict_scaling_factor = 120
top_k = 8
top_p = 0.1
temperature = 0.01
temperature_scaling_factor = 0.005
num_ctx = 8000
prompt = "Task Objective: {compression_instruction} Focus only on the most essential points and generate a summary that is no more than a few sentences. The summary should be as concise as possible while preserving the key details. Cleaned Narrative: '{cleaned_narrative}' Begin Summary:"


================================================================================
File: ./Archive/userdash.py
================================================================================

import streamlit as st
import redis
import json

# Initialize Redis connection
r = redis.StrictRedis(host='localhost', port=6379, db=0, decode_responses=True)

# User login
st.title("User Dashboard")
username = st.text_input("Username")
password = st.text_input("Password", type="password")

if username and password:  # Add more robust auth later

    # Fetch entries from Redis
    entries = json.loads(r.get('evaluation_entries'))

    for i, entry in enumerate(entries):
        st.write(f"Entry {i + 1}")
        st.json(entry)  # Display the entry content

        # Evaluation form
        rating = st.slider(f"Rate the Summary and Tags for Entry {i + 1}", 1, 5, 3)
        feedback = st.text_area(f"Feedback for Entry {i + 1}", "")

        if st.button(f"Submit Evaluation for Entry {i + 1}"):
            # Store user submission in Redis (could be keyed by username)
            user_data = {'rating': rating, 'feedback': feedback}
            r.rpush(f'evaluations_{username}', json.dumps(user_data))
            st.success(f"Evaluation submitted for Entry {i + 1}.")


================================================================================
File: ./Archive/overview_page.py
================================================================================

# overview_page.py

import streamlit as st

class OverviewPage:
    def __init__(self, institution_manager, institution):
        self.institution_manager = institution_manager
        self.institution = institution

    def show(self):
        st.header(f"Overview Mode - {self.institution}")

        # Use entries from session state
        all_entries = st.session_state.get('all_entries', [])
        total_entries = len(all_entries)

        # Get selected entries
        selected_entries = [
            entry for entry in all_entries if entry.get('Selected') == 'Select for Evaluation'
        ]
        total_selected = len(selected_entries)

        if total_selected == 0:
            st.write("No selected entries available.")
            st.markdown(f"**Total Selected Entries:** {total_selected}")
            st.markdown(f"**Total Entries in Database:** {total_entries}")
            return

        # Add search input and filter options
        st.markdown("### Search and Filter Selected Entries")

        # Search input
        search_query = st.text_input("Search by Narrative or Assigned Tags", key='overview_search_query')

        # Filter options
        all_tags = set()
        for entry in selected_entries:
            tags = entry.get('Assigned Tags', '').split(',')
            tags = [tag.strip() for tag in tags if tag.strip()]
            all_tags.update(tags)

        tag_filter = st.multiselect(
            "Filter by Assigned Tags",
            options=sorted(all_tags),
            key='overview_tag_filter'
        )

        # Filter selected entries based on search and filter criteria
        filtered_entries = selected_entries

        # Apply search filter
        if search_query:
            filtered_entries = [
                entry for entry in filtered_entries
                if search_query.lower() in entry.get('Narrative', '').lower() or
                   search_query.lower() in entry.get('Assigned Tags', '').lower()
            ]

        # Apply tag filter
        if tag_filter:
            filtered_entries = [
                entry for entry in filtered_entries
                if any(tag.strip() in tag_filter for tag in entry.get('Assigned Tags', '').split(','))
            ]

        # Update total entries after filtering
        total_filtered_entries = len(filtered_entries)

        if total_filtered_entries == 0:
            st.warning("No selected entries match the search and filter criteria.")
            st.markdown(f"**Total Selected Entries:** {total_selected}")
            st.markdown(f"**Total Entries in Database:** {total_entries}")
            st.markdown(f"**Number of Filtered Entries:** {total_filtered_entries}")
            return

        # Jump to Selected Entry
        st.markdown("### Jump to Selected Entry")
        selected_event_numbers = [entry['Event Number'] for entry in filtered_entries]
        selected_event_num = st.selectbox(
            "Select Event",
            selected_event_numbers,
            key='overview_event_num'
        )

        selected_entry = next(
            (entry for entry in filtered_entries if entry['Event Number'] == selected_event_num), None
        )

        # Display the selected entry
        if selected_entry:
            st.write(f"### Event Number: {selected_entry['Event Number']}")
            st.write(f"**Succinct Summary:** {selected_entry.get('Succinct Summary', 'N/A')}")
            st.write(f"**Tags:** {selected_entry.get('Assigned Tags', 'N/A')}")
        else:
            st.write("No selected entries available.")

        # Summary at the bottom
        st.markdown(f"**Total Selected Entries:** {total_selected}")
        st.markdown(f"**Number of Filtered Entries:** {total_filtered_entries}")
        st.markdown(f"**Total Entries in Database:** {total_entries}")


        # Slider to navigate filtered entries
        st.markdown("### Navigate Entries")
        index = st.slider(
            "Select Entry",
            min_value=0,
            max_value=total_filtered_entries - 1,
            value=0,
            format="Entry %d",
            key='overview_entry_slider'
        )

        selected_entry = filtered_entries[index]

        # Display progress bar or visual indicator
        progress = (index + 1) / total_filtered_entries
        st.progress(progress)

        # Display the selected entry
        st.write(f"### Event Number: {selected_entry['Event Number']}")
        st.write(f"**Succinct Summary:** {selected_entry.get('Succinct Summary', 'N/A')}")
        st.write(f"**Tags:** {selected_entry.get('Assigned Tags', 'N/A')}")

        # Summary at the bottom
        st.markdown(f"**Total Selected Entries:** {total_selected}")
        st.markdown(f"**Number of Filtered Entries:** {total_filtered_entries}")
        st.markdown(f"**Total Entries in Database:** {total_entries}")

================================================================================
File: ./Archive/helper.py
================================================================================

# helper.py

def load_institution_data(redis_manager, institution):
    selected_entries = redis_manager.get_selected_entries(institution)
    evaluation_scores = redis_manager.get_evaluation_scores(institution)
    return selected_entries, evaluation_scores

def save_institution_data(redis_manager, institution, selected_entries, evaluation_scores):
    redis_manager.save_selected_entries(institution, selected_entries)
    redis_manager.save_evaluation_scores(institution, evaluation_scores)

================================================================================
File: ./Archive/app.py
================================================================================

# app.py

import streamlit as st
import pandas as pd
from redis_manager import RedisManager, RedisSnapshotManager
from login_manager import LoginManager
from institution_manager import InstitutionManager
from network_resolver import NetworkResolver
from selection_page import SelectionPage
from overview_page import OverviewPage
from analysis_page import AnalysisPage  # Import AnalysisPage
import configparser
import logging

# Set up logging for debugging
logging.basicConfig(level=logging.INFO)

# Load the configuration file
config = configparser.ConfigParser()
config.read('config.ini')

# Initialize the NetworkResolver
resolver = NetworkResolver(config)

# Resolve Redis host and Ollama API endpoint
redis_host = resolver.resolve_host()
ollama_endpoint = resolver.resolve_ollama_endpoint()

# Connect to Redis
redis_port = config['Redis'].getint('redis_port', 6379)
redis_manager = RedisManager(redis_host, redis_port)

# Initialize the InstitutionManager
institution_manager = InstitutionManager(redis_manager)

# Set up the snapshot manager
snapshot_manager = RedisSnapshotManager(redis_manager.redis_client)

# Set up LoginManager
login_manager = LoginManager()

# Streamlit UI
st.title("Admin Dashboard")

# Check if user is logged in by verifying session state
if 'logged_in' not in st.session_state:
    st.session_state['logged_in'] = False

def reset_session_state():
    """Reset session state variables."""
    st.session_state.pop('all_entries', None)
    st.session_state.pop('selected_entries', None)
    st.session_state.pop('total_entries', None)
    st.session_state.pop('current_index', None)

def reset_institution_data():
    """Reset data in Redis and reset session state variables."""
    selected_institution = st.session_state.get('institution_select', 'UAB')  # Default to 'UAB' if not set
    institution_manager.reset_institution_data(selected_institution)  # Reset data in Redis
    reset_session_state()

# If the user is not logged in, show the login form
if not st.session_state['logged_in']:
    st.markdown("## Admin Login")
    admin_username = st.text_input("Username")
    admin_password = st.text_input("Password", type="password")

    if st.button("Login"):
        if login_manager.login(st.session_state, admin_username, admin_password):
            st.session_state['logged_in'] = True  # Set the logged_in flag to True on successful login
            st.success("Login successful!")
            st.rerun()  # Refresh the page after login
        else:
            st.error("Invalid username or password")
else:
    # Check if the user has admin role
    if st.session_state.get('user_role') != 'admin':
        st.error("You do not have permission to access this page.")
        if st.button("Logout"):
            login_manager.logout(st.session_state)
            st.session_state['logged_in'] = False
            st.rerun()
    else:
        # If the user is logged in and has admin role, display the dashboard

        # Handle institution selection with a callback to reset the session state
        institution = st.selectbox(
            "Select Institution", ["UAB", "MBPCC"],
            key='institution_select',
            on_change=reset_session_state
        )

        # Pull all entries from Redis or refresh when institution is changed
        if 'all_entries' not in st.session_state or not st.session_state['all_entries']:
            all_entries, _ = institution_manager.get_institution_data(institution)
            st.session_state['all_entries'] = all_entries
            st.session_state['total_entries'] = len(all_entries)
        else:
            all_entries = st.session_state['all_entries']
            st.session_state['total_entries'] = len(all_entries)  # Ensure total_entries is updated

        # Get selected entries
        selected_entries = [entry for entry in st.session_state['all_entries'] if entry.get('Selected') == 'Select for Evaluation']

        # Total selected
        total_selected = len(selected_entries)
        total_entries = st.session_state.get('total_entries', 0)

        # Update mode selection to include Analysis Mode
        mode = st.radio("Choose Mode", ["Selection Mode", "Overview Mode", "Analysis Mode"], index=0)

        # Display the appropriate page based on the selected mode
        if mode == "Analysis Mode":
            analysis_page = AnalysisPage(institution_manager, redis_manager)
            analysis_page.show()
        if mode == "Selection Mode":
            selection_page = SelectionPage(institution_manager, institution)
            selection_page.show()
        elif mode == "Overview Mode":
            overview_page = OverviewPage(institution_manager, institution)
            overview_page.show()

            # Only display administrative options in Overview Mode
            # Redis Snapshot and Reload Functionality
            st.markdown("### Redis Snapshot and Data Management")

            col1, col2, col3 = st.columns([1, 1, 1])

            with col1:
                if st.button("Take Snapshot"):
                    snapshot_manager.take_snapshot(institution)
                    st.success(f"Snapshot for {institution} taken successfully!")
                    st.rerun()

            with col2:
                if st.button("Reload Snapshot"):
                    snapshot_manager.load_snapshot(institution)
                    reset_session_state()  # Clear session state variables
                    st.success(f"Reloaded {institution} data from snapshot!")
                    st.rerun()

            with col3:
                if st.button("Reset Data"):
                    reset_institution_data()
                    st.success(f"All data for {institution} has been reset.")
                    st.rerun()

            # Handle new data upload
            st.markdown("### Upload New Data")

            with st.form(key='upload_form'):
                uploaded_file = st.file_uploader("Upload New Data", type="xlsx")
                submit_upload = st.form_submit_button('Upload')

            if submit_upload:
                if uploaded_file is not None:
                    try:
                        df = pd.read_excel(uploaded_file)
                        new_entries = df.to_dict(orient="records")
                        # Initialize entries with default values
                        institution_manager.initialize_entries(institution, new_entries)
                        reset_session_state()  # Clear session state variables
                        st.success(f"New data for {institution} uploaded successfully!")
                        st.rerun()  # Refresh the page to update counts
                    except Exception as e:
                        st.error(f"Error processing uploaded file: {e}")
                else:
                    st.warning("Please upload a file before clicking 'Upload'.")

        elif mode == "Analysis Mode":
            analysis_page = AnalysisPage(institution_manager)
            analysis_page.show()

        # Show total number of entries in the interface
        st.write(f"Total number of entries in database: {total_entries}")

        # Logout button
        if st.button("Logout"):
            login_manager.logout(st.session_state)
            st.session_state['logged_in'] = False  # Update the session state to indicate logout
            st.rerun()  # Refresh the page after logout

================================================================================
File: ./Archive/postgres_manager.py
================================================================================

import logging
import psycopg2
import json  # Add this import to resolve the error

class PostgresManager:
    """Handles PostgreSQL interactions for institutions, entries, and evaluations."""

    def __init__(self, host, port, user, password, dbname):
        try:
            self.connection = psycopg2.connect(
                host=host, port=port, user=user, password=password, dbname=dbname
            )
            self.logger = logging.getLogger(__name__)
            self.initialize_tables()  # Ensure tables exist at startup
            self.logger.info("PostgreSQL connection established and tables initialized successfully.")
        except Exception as e:
            self.logger.error(f"Failed to establish PostgreSQL connection: {e}")
            raise e
            
    def initialize_tables(self):
        """Creates required tables in PostgreSQL if they do not exist."""
        try:
            with self.connection.cursor() as cursor:
                # Create entries table
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS entries (
                        id SERIAL PRIMARY KEY,
                        institution VARCHAR(255),
                        event_number INT,
                        data JSONB
                    );
                """)

                # Create evaluations table
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS evaluations (
                        id SERIAL PRIMARY KEY,
                        institution VARCHAR(255),
                        evaluator VARCHAR(255),
                        entry_number INT,
                        summary_score DECIMAL(5, 2),
                        tag_score DECIMAL(5, 2),
                        feedback TEXT
                    );
                """)

                # Commit the changes
                self.connection.commit()
                self.logger.info("Required tables are present in PostgreSQL.")
        except Exception as e:
            self.logger.error(f"Failed to initialize PostgreSQL tables: {e}")
            self.connection.rollback()  # Rollback in case of error

    def reset_institution_data(self, institution):
        """Resets data for an institution by clearing the entries and evaluations."""
        try:
            with self.connection.cursor() as cursor:
                cursor.execute("DELETE FROM entries WHERE institution = %s;", (institution,))
                cursor.execute("DELETE FROM evaluations WHERE institution = %s;", (institution,))
                self.connection.commit()
                self.logger.info(f"Data for institution {institution} has been reset.")
        except Exception as e:
            self.logger.error(f"Failed to reset data for institution {institution}: {e}")
            self.connection.rollback()
            raise e

    def save_selected_entries(self, institution, selected_entries):
        """Save selected entries for the institution in PostgreSQL."""
        try:
            with self.connection.cursor() as cursor:
                for entry in selected_entries:
                    cursor.execute("""
                        INSERT INTO entries (institution, event_number, data)
                        VALUES (%s, %s, %s)
                        ON CONFLICT (institution, event_number)
                        DO UPDATE SET data = %s
                    """, (institution, entry['Event Number'], json.dumps(entry), json.dumps(entry)))
                self.connection.commit()
                self.logger.info(f"Selected entries saved for institution {institution}.")
        except Exception as e:
            self.logger.error(f"Failed to save selected entries for institution {institution}: {e}")
            self.connection.rollback()

    def save_evaluation_scores(self, institution, evaluation_scores):
        """Save evaluation scores for the institution in PostgreSQL."""
        try:
            with self.connection.cursor() as cursor:
                for entry_number, evaluations in evaluation_scores.items():
                    for evaluation in evaluations:
                        cursor.execute("""
                            INSERT INTO evaluations (institution, evaluator, entry_number, summary_score, tag_score, feedback)
                            VALUES (%s, %s, %s, %s, %s, %s)
                            ON CONFLICT (institution, evaluator, entry_number)
                            DO UPDATE SET summary_score = %s, tag_score = %s, feedback = %s
                        """, (institution, evaluation['Evaluator'], entry_number, 
                              evaluation['Summary Score'], evaluation['Tag Score'], evaluation['Feedback'],
                              evaluation['Summary Score'], evaluation['Tag Score'], evaluation['Feedback']))
                self.connection.commit()
                self.logger.info(f"Evaluation scores saved for institution {institution}.")
        except Exception as e:
            self.logger.error(f"Failed to save evaluation scores for institution {institution}: {e}")
            self.connection.rollback()

    def get_selected_entries(self, institution):
        """Retrieve selected entries for a specific institution from PostgreSQL."""
        try:
            with self.connection.cursor() as cursor:
                cursor.execute("SELECT event_number, data FROM entries WHERE institution = %s;", (institution,))
                result = cursor.fetchall()
                selected_entries = [json.loads(row[1]) for row in result]
                self.logger.info(f"Selected entries retrieved for institution {institution}.")
                return selected_entries
        except Exception as e:
            self.logger.error(f"Failed to retrieve selected entries for institution {institution}: {e}")
            return []

    def get_evaluation_scores(self, institution):
        """Retrieve evaluation scores for a specific institution from PostgreSQL."""
        try:
            with self.connection.cursor() as cursor:
                cursor.execute("""
                    SELECT evaluator, entry_number, summary_score, tag_score, feedback 
                    FROM evaluations WHERE institution = %s;
                """, (institution,))
                result = cursor.fetchall()
                evaluation_scores = {}
                for row in result:
                    entry_number = row[1]
                    if entry_number not in evaluation_scores:
                        evaluation_scores[entry_number] = []
                    evaluation_scores[entry_number].append({
                        'Evaluator': row[0],
                        'Summary Score': row[2],
                        'Tag Score': row[3],
                        'Feedback': row[4]
                    })
                self.logger.info(f"Evaluation scores retrieved for institution {institution}.")
                return evaluation_scores
        except Exception as e:
            self.logger.error(f"Failed to retrieve evaluation scores for institution {institution}: {e}")
            return {}

    def update_institution_stats(self, institution, cumulative_summary, cumulative_tag, total_evaluations):
        """Update or insert institution statistics in PostgreSQL."""
        try:
            with self.connection.cursor() as cursor:
                cursor.execute("""
                    INSERT INTO institution_stats (institution, cumulative_summary, cumulative_tag, total_evaluations)
                    VALUES (%s, %s, %s, %s)
                    ON CONFLICT (institution)
                    DO UPDATE SET cumulative_summary = %s, cumulative_tag = %s, total_evaluations = %s
                """, (institution, cumulative_summary, cumulative_tag, total_evaluations,
                      cumulative_summary, cumulative_tag, total_evaluations))
                self.connection.commit()
                self.logger.info(f"Institution stats updated for institution {institution}.")
        except Exception as e:
            self.logger.error(f"Failed to update institution stats for {institution}: {e}")
            self.connection.rollback()

    def get_institution_stats(self, institution):
        """Retrieve institution statistics from PostgreSQL."""
        try:
            with self.connection.cursor() as cursor:
                cursor.execute("""
                    SELECT cumulative_summary, cumulative_tag, total_evaluations 
                    FROM institution_stats WHERE institution = %s;
                """, (institution,))
                result = cursor.fetchone()
                if result:
                    return {
                        'cumulative_summary': result[0],
                        'cumulative_tag': result[1],
                        'total_evaluations': result[2]
                    }
                else:
                    self.logger.warning(f"No stats found for institution {institution}.")
                    return {
                        'cumulative_summary': 0.0,
                        'cumulative_tag': 0.0,
                        'total_evaluations': 0
                    }
        except Exception as e:
            self.logger.error(f"Failed to retrieve institution stats for {institution}: {e}")
            return {
                'cumulative_summary': 0.0,
                'cumulative_tag': 0.0,
                'total_evaluations': 0
            }

================================================================================
File: ./Archive/selection_page.py
================================================================================

# selection_page.py

import streamlit as st
import random
import streamlit.components.v1 as components

class SelectionPage:
    def __init__(self, institution_manager, institution):
        self.institution_manager = institution_manager
        self.institution = institution

    def show(self):
        st.header(f"Selection Mode - {self.institution}")

        # Use entries from session state
        entries = st.session_state.get('all_entries', [])
        total_entries = len(entries)

        # Add search input and filter options
        st.markdown("### Search and Filter Entries")

        # Search input
        search_query = st.text_input("Search by Narrative or Assigned Tags", key='selection_search_query')

        # Filter options
        col1, col2 = st.columns(2)
        with col1:
            selection_filter = st.selectbox(
                "Filter by Selection Status",
                options=["All", "Selected", "Not Selected"],
                key='selection_filter'
            )
        with col2:
            # Filter by Assigned Tag
            all_tags = set()
            for entry in entries:
                tags = entry.get('Assigned Tags', '').split(',')
                tags = [tag.strip() for tag in tags if tag.strip()]
                all_tags.update(tags)
            tag_filter = st.multiselect(
                "Filter by Assigned Tags",
                options=sorted(all_tags),
                key='tag_filter'
            )

        # Filter entries based on search and filter criteria
        filtered_entries = entries

        # Apply search filter
        if search_query:
            filtered_entries = [
                entry for entry in filtered_entries
                if search_query.lower() in entry.get('Narrative', '').lower() or
                   search_query.lower() in entry.get('Assigned Tags', '').lower()
            ]

        # Apply selection status filter
        if selection_filter != "All":
            status = 'Select for Evaluation' if selection_filter == "Selected" else 'Do Not Select'
            filtered_entries = [
                entry for entry in filtered_entries
                if entry.get('Selected', 'Do Not Select') == status
            ]

        # Apply tag filter
        if tag_filter:
            filtered_entries = [
                entry for entry in filtered_entries
                if any(tag.strip() in tag_filter for tag in entry.get('Assigned Tags', '').split(','))
            ]

        # Update total entries after filtering
        total_filtered_entries = len(filtered_entries)

        # Handle case where no entries match the filters
        if total_filtered_entries == 0:
            st.warning("No entries match the search and filter criteria.")
            return

        # Button to select 200 random entries
        if st.button("Select 200 Random Entries"):
            num_to_select = 200
            # From the filtered entries, get unselected entries
            unselected_entries = [
                entry for entry in filtered_entries
                if entry.get('Selected', 'Do Not Select') == 'Do Not Select'
            ]
            num_available = len(unselected_entries)
            if num_available == 0:
                st.warning("No unselected entries are available to select.")
            else:
                num_to_select = min(num_to_select, num_available)
                random_entries = random.sample(unselected_entries, num_to_select)
                for entry in random_entries:
                    entry['Selected'] = 'Select for Evaluation'
                    # Update entry in Redis
                    self.institution_manager.update_entry(self.institution, entry)
                    # Update session state
                    for idx, e in enumerate(st.session_state['all_entries']):
                        if e['Event Number'] == entry['Event Number']:
                            st.session_state['all_entries'][idx]['Selected'] = 'Select for Evaluation'
                            break
                st.success(f"{num_to_select} random entries have been selected for evaluation.")

        # Initialize current index if not set
        if 'current_index' not in st.session_state:
            st.session_state['current_index'] = 0

        # Ensure current_index is within bounds
        if st.session_state.current_index >= total_filtered_entries:
            st.session_state.current_index = total_filtered_entries - 1
        if st.session_state.current_index < 0:
            st.session_state.current_index = 0

        # Navigation
        st.markdown("### Navigate Entries")

        # Navigation buttons
        col1, col2, col3 = st.columns([1, 2, 1])
        with col1:
            if st.button("Previous Entry") and st.session_state.current_index > 0:
                st.session_state.current_index -= 1
        with col2:
            # Slider to navigate entries (enumerated from 1)
            st.session_state.current_index = st.slider(
                "Select Entry",
                min_value=1,
                max_value=total_filtered_entries,
                value=st.session_state.current_index + 1,
                format="Entry %d",
                key='entry_slider'
            ) - 1  # Adjust index to be 0-based
        with col3:
            if st.button("Next Entry") and st.session_state.current_index < total_filtered_entries - 1:
                st.session_state.current_index += 1

        # Display progress bar or visual indicator
        progress = (st.session_state.current_index + 1) / total_filtered_entries
        st.progress(progress)

        current_entry = filtered_entries[st.session_state.current_index]

        entry_number_display = st.session_state.current_index + 1

        # Display the current entry with enumeration from 1
        st.write(f"### Entry {entry_number_display} of {total_filtered_entries} - Event Number: {current_entry.get('Event Number', 'N/A')}")

        st.write(f"**Narrative:** {current_entry.get('Narrative', '')}")
        st.write(f"**Cleaned Narrative:** {current_entry.get('Cleaned Narrative', '')}")
        st.write(f"**Assigned Tags:** {current_entry.get('Assigned Tags', '')}")
        st.write(f"**Evaluation:** {current_entry.get('Evaluation', '')}")
        st.write(f"**Succinct Summary:** {current_entry.get('Succinct Summary', '')}")

        # Selection checkbox
        is_selected = current_entry.get('Selected', 'Do Not Select') == 'Select for Evaluation'
        selection = st.checkbox(
            "Select this entry for evaluation",
            value=is_selected,
            key=f"select_{current_entry.get('Event Number', st.session_state.current_index)}"
        )

        # Inject JavaScript for hotkey (Press 'T' to toggle selection)
        # Note: This method may have limitations across different browsers and is not guaranteed to work reliably.
        components.html(f"""
        <script>
            const doc = window.parent.document;
            const checkbox = doc.querySelector('input[data-testid="stSessionState-select_{current_entry.get('Event Number', st.session_state.current_index)}"]');
            document.addEventListener('keydown', function(event) {{
                if (['INPUT', 'TEXTAREA'].indexOf(doc.activeElement.tagName) === -1) {{
                    if (event.code === 'KeyT') {{
                        if (checkbox) {{
                            checkbox.click();
                        }}
                    }}
                }}
            }});
        </script>
        """, height=0)

        # Update selection status if changed
        if selection != is_selected:
            selection_status = 'Select for Evaluation' if selection else 'Do Not Select'
            current_entry['Selected'] = selection_status

            # Update entry in Redis
            self.institution_manager.update_entry(self.institution, current_entry)

            # Update session state
            for idx, entry in enumerate(st.session_state['all_entries']):
                if entry['Event Number'] == current_entry['Event Number']:
                    st.session_state['all_entries'][idx]['Selected'] = selection_status
                    break

            st.success(f"Entry {current_entry.get('Event Number', 'N/A')} updated.")

        # Summary at the bottom
        st.markdown(f"**Total Filtered Entries:** {total_filtered_entries}")
        st.markdown(f"**Total Entries in Database:** {total_entries}")

================================================================================
File: ./Archive/analysis_page.py
================================================================================

# analysis_page.py

import streamlit as st
from institution_manager import InstitutionManager
from redis_manager import RedisManager
from network_resolver import NetworkResolver
import configparser

class AnalysisPage:
    def __init__(self, institution_manager, redis_manager):
        self.institution_manager = institution_manager
        self.redis_manager = redis_manager

    def show(self):
        st.header("Analysis Mode")

        # List of institutions
        institutions = ["UAB", "MBPCC"]

        # Check if there are any evaluations
        total_entries = 0
        total_evaluations = 0
        institution_stats_list = []

        for institution in institutions:
            # Get institution data
            entries, _ = self.institution_manager.get_institution_data(institution)
            total_entries += len(entries)

            # Retrieve stats from Redis
            stats_key = f"{institution}_stats"
            stats = self.redis_manager.redis_client.hgetall(stats_key)

            if stats:
                cumulative_summary = float(stats.get('cumulative_summary', 0))
                cumulative_tag = float(stats.get('cumulative_tag', 0))
                total_evals = int(stats.get('total_evaluations', 0))

                if total_evals > 0:
                    avg_summary = cumulative_summary / total_evals
                    avg_tag = cumulative_tag / total_evals
                else:
                    avg_summary = 0.0
                    avg_tag = 0.0

                total_evaluations += total_evals

                institution_stats_list.append({
                    'Institution': institution,
                    'Average Summary Score': round(avg_summary, 2),
                    'Average Tag Score': round(avg_tag, 2),
                    'Total Evaluations': total_evals
                })
            else:
                institution_stats_list.append({
                    'Institution': institution,
                    'Average Summary Score': 0.0,
                    'Average Tag Score': 0.0,
                    'Total Evaluations': 0
                })

        if total_evaluations == 0:
            st.write("No evaluations have been submitted yet.")
            st.markdown(f"**Total Entries in Database:** {total_entries}")
            return

        # Display institution-wise averages
        st.subheader("Institution Averages")

        # Display the statistics
        for stats in institution_stats_list:
            st.write(f"**{stats['Institution']}**")
            st.write(f"- Average Summary Score: {stats['Average Summary Score']}")
            st.write(f"- Average Tag Score: {stats['Average Tag Score']}")
            st.write(f"- Total Evaluations: {stats['Total Evaluations']}")

        # Calculate combined averages
        total_cumulative_summary = sum(
            float(self.redis_manager.redis_client.hget(f"{inst}_stats", 'cumulative_summary') or 0)
            for inst in institutions
        )
        total_cumulative_tag = sum(
            float(self.redis_manager.redis_client.hget(f"{inst}_stats", 'cumulative_tag') or 0)
            for inst in institutions
        )

        if total_evaluations > 0:
            combined_avg_summary_score = total_cumulative_summary / total_evaluations
            combined_avg_tag_score = total_cumulative_tag / total_evaluations
            combined_aggregate_score = (combined_avg_summary_score + combined_avg_tag_score) / 2
        else:
            combined_avg_summary_score = 0.0
            combined_avg_tag_score = 0.0
            combined_aggregate_score = 0.0

        st.subheader("Combined Averages Across All Institutions")
        col1, col2, col3 = st.columns(3)
        with col1:
            st.metric("Combined Average Summary Score", f"{combined_avg_summary_score:.2f}")
        with col2:
            st.metric("Combined Average Tag Score", f"{combined_avg_tag_score:.2f}")
        with col3:
            st.metric("Combined Aggregate Score", f"{combined_aggregate_score:.2f}")

        # Summary at the bottom
        st.markdown(f"**Total Evaluations Across All Institutions:** {total_evaluations}")
        st.markdown(f"**Total Entries in Database:** {total_entries}")


================================================================================
File: ./Archive/network_resolver.py
================================================================================

# network_resolver.py

import socket
import logging

class NetworkResolver:
    def __init__(self, config):
        self.config = config
        self.logger = logging.getLogger(__name__)

    def get_local_ip(self):
        """Get the local IP address of the machine."""
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        try:
            # Use an external server to determine local IP
            s.connect(('8.8.8.8', 1))
            local_ip = s.getsockname()[0]
            self.logger.info(f"Local IP detected: {local_ip}")
            return local_ip
        except Exception as e:
            self.logger.error(f"Failed to determine local IP: {e}")
            raise Exception("Unable to determine local IP address.")
        finally:
            s.close()

    def resolve_environment(self, local_ip):
        """Determine the environment based on the local IP address."""
        if local_ip.startswith('192.168.1.'):
            self.logger.info("Detected home network.")
            return 'home'
        elif local_ip.startswith('172.30.98.'):
            self.logger.info("Detected work network.")
            return 'work'
        else:
            self.logger.warning(f"Unknown subnet {local_ip}. Defaulting to 'home' environment.")
            return 'home'  # Default to 'home' if subnet is unknown

    def resolve_host(self):
        """Determine the appropriate Redis host based on local subnet information."""
        local_ip = self.get_local_ip()
        environment = self.resolve_environment(local_ip)
        redis_host_key = f"host_{environment}"
        try:
            redis_host = self.config['Redis'][redis_host_key]
            self.logger.info(f"Using Redis host for {environment} environment: {redis_host}")
            return redis_host
        except KeyError:
            raise KeyError(f"Redis host configuration '{redis_host_key}' not found in config.ini.")

    def resolve_ollama_endpoint(self):
        """Resolve the correct Ollama API endpoint based on the network."""
        local_ip = self.get_local_ip()
        environment = self.resolve_environment(local_ip)
        endpoint_key = f"endpoint_{environment}"
        try:
            ollama_endpoint = self.config['API'][endpoint_key]
            self.logger.info(f"Using Ollama API endpoint for {environment} environment: {ollama_endpoint}")
            return ollama_endpoint
        except KeyError:
            raise KeyError(f"API endpoint configuration '{endpoint_key}' not found in config.ini.")

    def resolve_all(self):
        """Resolve both Redis host and Ollama API endpoint."""
        local_ip = self.get_local_ip()
        environment = self.resolve_environment(local_ip)
        redis_host = self.resolve_host()
        ollama_endpoint = self.resolve_ollama_endpoint()
        return redis_host, ollama_endpoint
